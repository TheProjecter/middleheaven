<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<author>Sérgio Taborda</author>
		<title>Criteria Toolbox </title>
	</properties>
	<body>
	<section name="Criteria Toolbox">
	<p>
	Será raro o software de negócio que não trabalhe com algum tipo de dado. Uma das operações mais comuns 
	neste tipo de sistema é concerteza a de procurar dados conforme alguma critério. A <toolbox>Criteria Tooblox</toolbox> é a
	resposta do MiddleHeaven a como definir, de forma independente, um critério de busca de dados.
	</p>
	<p>
	A <toolbox>Criteria Tooblox</toolbox> especializa-se em construir objectos <code>Criteria</code>. "Criteria" é o plural de "Criterion" (critério), portanto,
	um objecto de criteria é uma conjunto de objectos criterion. O objecto <code>Criteria</code> segue o padrão <pattern>QueryObject</pattern>
	em que um objecto unico contém toda a informação necessária para definir uma pesquisa contra um repositorio de dados. 
	</p>
	<p>
	A construção de um objecto <code>Criteria</code> é mediada por um <code>CriteriaBuilder</code> que segue o padrão <pattern>Builder</pattern>
	Isso torna a construção simples, fluente e fortemente tipada.
	</p>
	<p>
	A <toolbox>Criteria Tooblox</toolbox> constroi critérios de pesquisa baseados em objectos.
	</p>
	</section>
	<section name="Pesquisas" >
	<section name="Todos" >
	<p>
	A primeira pesquisa que queremos conseguir é obter todas as instancias
	de uma certa classe que possam existir no repositorio. Para uma classe <code>Subject</code>
	teriamos:
	<source>
	Criteria&lt;Subject&gt; all = CriteriaBuilder.search(Subject.class).all();
	</source>
	Que se pode ler como "Pesquisa (<estrang>search</estrang>) por objecto da classe Subject e obtém todos (<estrang>all</estrang>)".
	</p>
	O método <code>search</code> é estático, portanto, se desejar pode usar o recurso de importe estático (<estrang>import static</estrang>)
	e simplificar o codigo :
	<source>
	Criteria&lt;Subject&gt; all = search(Subject.class).all();
	</source>
	Contudo, esta opção não é recomendada já que as Boas Práticas indicam que métodos estáticos devem ser chamados explicitamente
	na interface que os define. Você decide.
	<p>
	Esta pesquisa é simples, mas normalmente gostariamos de mais algum refinamento.
	</p>
	</section>
	<section name="Por atributos">
	<p>
	Como o critério apenas será aplicado a objetos a forma de refinar a pesquisa é estabelecendo
	restrições para os seus atributos. Imaginemos que Subject tem um atributo "name". A pesquisa
	sequinte encontrará "Todos os Subject cujo <estrang>name</estrang> <i>não é</i> exactamente <i>Brian</i>"
	<source>
	Criteria&lt;Subject&gt; brians = search(Subject.class)
		.and("name").not().eq("Brian")
		.all();
	</source>
	O operador <code>and</code> adiciona a restrição pelo nome à pesquisa original que sempre encontra todos.
	O operador <code>not</code> nega o operador seguinte, no caso o operado de igualdade, gerando o operador "diferente de".
	</p>
	<p>
	Podemos restringir a pesquisa o quanto quisermos:
	<source>
	Criteria&lt;Subject&gt; danielAtivos = CriteriaBuilder.search(Subject.class)
				.and("name").not().startsWith("Daniel")
				.and("active").not().eq(false)
				.all()
	</source>
	O operador "and" pode ser utilizado repetidamente. Note-se que escrevemos
	uma dupla negação procurando pelos Subject cujo atributo "active" não é falso.
	Isto pode parecer que é o mesmo que procurar aqueles cujo atributo "active" é verdadeiro.
	Isso só é verdade se o atributo "active" só tiver dois estados. Se ele puder conter o valor <code>null</code>
	as duas pesquisas não são mais equivalente.
	</p>
	<p>
	Uma outra diferença é o uso de "startsWith" que procura por objectos cujo valor do atributo começa com um
	certo texto. Este operador só funciona para atributos textuais.
	</p>
	<p>
	Uma visita à interface <code>Constraint</code> irá mostrar todos os operadores que podem ser utilizados:
	<ul>
	<li>eq -igual a</li>
	<li>lt - menor que</li>
	<li>gt - maior que</li>
	<li>le - menor ou igual a</li>
	<li>ge - maior ou igual a</li>
	<li>startsWith - começa com</li>
	<li>endsWith - acaba com</li>
	<li>contains - contém</li>
	<li>in - está contido em um intervalo ou conjunto de valores</li>
	<li>bewteen - está contido entre dois valores</li>
	<li>not - nega a condição de restrição seguinte. Usado para negar todos os outros operadores</li>
	</ul>
	</p>
	</section>
	<section name="Ordenação">
	<p>
	Restringir a pesquisa é capacidade importante, mas também o é, ser capaz de ordenar o resultado da pesquisa.
	A <toolbox>Criteria Tooblox</toolbox> permite isso de uma forma muito simples:
	<source>
	Criteria&lt;Subject&gt; bornInXXcentury = CriteriaBuilder.search(Subject.class)
				.and("birthday").bewteen( 
					CalendarDate.date(1900,1,1), 
					CalendarDate.date(2000,12,31)
					)
				.orderBy("birthday").asc()
				.all()
	</source> 
	O operador <code>orderBy</code> permite escolher por qual atributo queremos ordenar e em qual direção queremos
	que a ordenação seja feita (asc - ascendente ou desc - descendente). Não pode ser mais simples que isto.
	O operador <code>orderBy</code> pode ser utilizado repetidamente para criar ordenação por multiplos atributos.
	Contudo é preciso notar que a sequencia em que os critérios de ordenação são adicionados é relevante para o resultado
	já que o MiddleHeaven irá ordenar os dados primeiro pelo primeiro critério adicionado, depois pelo segundo, etc...
	</p>
	</section>
	<section name="Fluência">
	<p>
	Escrever um critério de pesquisa pode ser extenso. A fluência do <code>CriteriaBuilder</code> permite que se
	escreva o critário como se em lingua natural o que facilita tanto a escrita como a leitura posterior. 
	Obter fluência na escrita do critério é um dos objetivos principais da <toolbox>Criteria Tooblox</toolbox> e conseguido através
	de diferentes tecnicas de encadeamento de métodos e encadeamento de construtores. Experimente. Verá que, por exemplo,
	após escrever "orderBy" as unicas opções possiveis a seguir são escrever "asc" ou "desc" o builder controla as suas opções
	à medida que escreve evitando erros. 
	</p>
	<p>
	Comparemos um critério criado como a <toolbox>Criteria Tooblox</toolbox> com um criado como 
	o <a href="https://www.hibernate.org/hib_docs/v3/api/org/hibernate/Criteria.html">Hibernate</a> ( 
	que também suporta o padrão <pattern>QueryObject</pattern>)
    e o tradicional SQL
    <source>
	SELECT *
	FROM Subject 
	WHERE name LIKE '%de%'
	ORDER BY birthday ASC
	<legend>SQL equivalente</legend>
	</source>
	<source>
	  Criteria criteria = hibernatesession.createCriteria(Subject.class);  
     .add(Restrictions.like("name","%de%") )
     .addOrder(Order.asc("birthday"));  
     <legend>Código com Hibernate</legend>
	</source> 
	<source>
	  Criteria&lt;Subject&gt; criteria = CriteriaBuilder.search(Subject.class);  
     .and("name").contains("de") 
     .orderBy("birthday").asc()
     .all();
     <legend>Código com MiddleHeaven Criteria Toolbox</legend>
	</source> 
	Semelhante, mas as diferenças são importantes. O principal problema com outras API de criterios é que para criar 
	o criério é preciso ter acesso a algum objecto especial da API que não diz respeito 
	a critérios. No caso do Hibernate é necessário ter acesso ao objecto Session. 
	A <toolbox>Criteria Tooblox</toolbox> é totalmente indepenente. Desta forma, o critério pode ser criado
	em qualquer ponto do sistema e até serializado se necessário. 
	</p>
	<p>
	Embora pareça que a API do Hibernate é fluente, ela não o é realmente
	porque necessita de vários métodos estáticos - especialmente os existentes em Restrictions e Order -
	para construir o critério. Além disso a sintaxe é amarrada a banco de dados já que "like" é um operador
	de banco de dados e o uso do sinal de porcentagem (<i>%</i>) é necessário para a API JDBC.
	A <toolbox>Criteria Tooblox</toolbox> não contém nenhuma dependencia com bancos de dados ou a API JDBC.
	Isto permite que o critério seja aplicado a qualquer tipo de repositorio de dados ( inclusive os que usam JDBC)
	e permite trocar o repositorio sem mudar o critério. Sendo que o critério de pesquisa é onde está a logica do negocio/dominio
	a preservação do critério é muito importante para não introduzir erros no sistema.  
	</p>
	<p>
	A <toolbox>Criteria Tooblox</toolbox> permite escrever critérios de uma forma muito próxima da tradicional SQL que 
	a maioria dos desenvolvedores domina, facilitando a transição. Para os novatos, o controle que a Criteria Toolbox
	impõe na sintaxe elimina erros de quem está aprendendo, além do que os permite escrever critérios
	que podem ser executados não apenas sobre bancos de dados, mas sobre muitos outros suportes de dados. 
	</p>
	</section>
	</section>
	<section name="Por detrás dos panos" >
	<p>
	O poder da <toolbox>Criteria Tooblox</toolbox> advém completamente da capacidade de orientação a objetos e generics 
	da linguagem Java, do padrão Builder , da tecnica de encadeamento de metodos (<estrang>method channing</estrang>)
	e da tecnica de encadeamento de builders (não ha um nome para isso ainda no mainstream, mas o Martin Fowler batizou uma ideia
	semelhante com o nome <a href="http://martinfowler.com/dslwip/MethodChaining.html" >"Progressive Interface"</a>). 
	</p>
	<p>
	Ou seja, o poder da MiddleHeaven <toolbox>Criteria Tooblox</toolbox> adém de orientação a objectos pura. Em um tempo
	em que ferramentas e API de manipulação de código são comuns é bom saber que ainda podemos ir longe se o uso 
	dessas tecnicas de <estrang>tunning</estrang> envenenadas. 
	</p>
	<p>
	A completa independencia da <toolbox>Criteria Tooblox</toolbox> do repositorio em que o critério seja executado permite 
	que o mesmo critério possa ser usado para diferentes repositorios. Contudo isso também significa que a 
	Criteria Toolbox não pode utilizar informação do modelo para ajudar a criar os critérios e validar
	as restrições. Isso é feito apenas no momento em que o critério é submetido ao repositorio de dados. 
	</p>
	</section>
	<section name="Execução">
	<p>
	Neste momento deve se estar perguntando como executar a pesquisa. Isso é feito por outra toolbox, mas aqui fica uma ideia de
	como funciona
	</p>
	<p>
	No MiddleHeaven os dados são guardados em objectos <code>DataStorage</code> que pertencem à <toolbox>Storage Toolbox</toolbox>.
	A execução é feita através de objecto <code>Query</code> que são criados pelo próprio <code>DataStorage</code>:
	<source>
		// define a pesquisa
		 Criteria&lt;Subject&gt; criteria = CriteriaBuilder.search(Subject.class);  
	     .and("name").contains("de") 
	     .orderBy("birthday").asc()
	     .all();
	     
	    // define a forma de execução
		Query&lt;Subject&gt; query = dataStorage.createQuery(criteria);
		
		// executa realmente
		List&lt;Subject&gt; subjects = query.findAll();
	</source>
	ou simplesmente :
	<source>

		List&lt;Subject&gt; subjects = dataStorage.createQuery(
			CriteriaBuilder.search(Subject.class);  
		     .and("name").contains("de") 
		     .orderBy("birthday").asc()
		     .all();
		).findAll();
		
	</source>
	O objecto intermediário <code>Query</code> permite executar o mesmo critério contra o mesmo repositorio de dados
	repetidas vezes sem passar pelo objecto de dataStorage todas as vezes. Desta forma o objecto <code>Query</code>
	pode ser criado apenas uma unica vez, guardado, e depois executado quando necessário. Por outro lado, a execução só
	acontece quando os métodos de <code>Query</code> são chamados. Diferentes métodos resultam em diferentes
	estratégias e é isso que dá flexibilidade e performance ao mecanismo. Mais detalhes disso
	na descrição da <toolbox>Storage Toolbox</toolbox>. 
	</p>
	</section>
	</body>
</document>
