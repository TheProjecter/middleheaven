<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<author>Sérgio Taborda</author>
		<title> Utilitários: Coleções </title>
	</properties>
	<body>
	<section name="Utilitátios" >
	<p>
	A plataforma java oferece uma vasto suporte ao 
	<a href="http://sergiotaborda.wordpress.com/java/colecoes-em-java/">
	conceito de conjuntos</a> (coleções e mapas), mas não tão vasto quanto 
	poderia ser. 
	</p>
	<p>
	A limitação à API de coleções atual é o uso da classe Colections para 
	coisas avanaçadas como ordenação e a falta de suporte a Closures pelo 
	Java. Mesmo se o Java tivesse suporte, depois das discussões para o Java 7 -
	a closures não ha garantia de que a API de coleções seria alterada.
	</p>
	<p>
	Mesmo com o suporte a coleções da plataforma falta suporte a outras estruturas 
	- que não sendo coleções - estão relacionadas a teoria de conjuntos como 
	intervalos.
	</p>
	</section>
	<section name="Intervalo" >
	<p>
	O MiddleHeaven dá suporta a intervalos pela classe <code>Interval</code> definida 
	conjunto de elementos ordenável. Elemento ordenável é todo aquele que implements <code>Comparable</code>
	ou a que se possa associar um <code>Comparator</code>.
	Um intervalo pode ser fechado ( tem principio e fim) , aberto ( sem principio
	ou sem fim) ou vazio ( o principio e o fim são iguais). 
	</p>
	<p>
	A classe <code>Interval</code> suporta várias operações que podem ser feitas 
	sobre ou com intervalos, tais como interseção, união ou verificar se um elemento 
	está no intervalo. 
	</p>
	<p>
	Era importante incluir conceito de intervalo. Isso é especialmente relevante 
	o dominio de tempos e datas (<a href="http://middleheaven.wordpress.com/toolboxes/quantidades-e-medidas/time-toolbox/">Time Toolbox</a>)
	onde é comum definir intervalos de tempo. O MiddleHeaven define <code>TimeInterval</code> 
	como uma extensão de <code>Interval</code> aplicada a <code>TimePoint</code> 
	e adiciona operações relacionadas a tempo como a conversão para <code>Period</code>
	</p>
	</section>
	<section name="Range" >
	<p>
	Um intervalo não é iterável porque ele pode ser aberto. Para ter um objeto semelhante a um intervalo 
	mas que é iterável temos o <code>Range</code>. O objeto <code>Range</code> parece-se muito com um intervalo, 
	mas podemos iterar os elementos através de um <code>Incrementator</code>.  
	Um incrementador permite passar de um elemento ao próximo de uma forma controlada. Por exemplo,
	para passar de 1 a 2 adicionamos 1, mas para passar de 2009-09-10 a 2009-09-11 temos que obter a proxima data.
	Não podemos simplesmente adicionar 1.
	</p>
	<p> 
    O incrementador é especialmente relevante para elementos de um conjunto ordenável e denso como os numeros reais, já que para estes tipos 
    de conjunto não podemos determinar qual é o proximo elemento a partir de um elemento dado. 
    Por exemplo, nos numeros reais, a seguir a 1 existe um numero, mas não é 2, nem 1.5, nem 1.1, 
    nem 1.0000001 , nem ... Por causa desta impossibilidade matemática, ao criar um <code>Range</code> sobre um 
    conjunto denso é necessário estabelecer o passo através de um incrementador. Por exemplo de 1 em 1, poderiamos
    iterar de 2 a 5 e teriamos [2, 3 ,4, 5] , mas como passo de 0.5 teriamos [2, 2.5 , 3 , 3.5 , 4 , 4.5 , 5].
	</p>
	</section>
	<section name="Caminhando sobre o conjunto">
	<p>
	A API de collections é muito boa usando o padrão Iterator ( um dos padrões GoF) mas falha usando o 
	padrão Visitor (também do GoF) . O padrão visitor é muito util para fazer passar um objeto por todos 
	os elementos da coleção.  Assim, a coleção recebe um objeto que visita todos os elementos para um 
	determinado fim. O padrão visitor é muito util porque esconde a iteração do for ou do while e 
	desta maneira deixa a coleção fazer a caminhada pelos elementos como ela quiser ( em tese da forma mais eficiente).  
	O padrão Visitor é aquele que seria utilzado por closures, caso elas existissem para aplicar uma certa logica
	a cada elementos do conjunto. O MiddleHeaven suporta o conceito por detrás do padrão visitor e introduz as 
	interfaces <code>Walkable</code> e <code>Walker</code>. Um <code>Walkable</code> é um objeto que pode 
	ser "caminhado" por um "caminhante" (<code>Walker</code>) em analogia a que um objeto  <code>Iterable</code> pode ser iterado
	através de um <code>Iterator</code>.  
	</p>
	<p>
	 A interface <code>Walker</code> apenas define um método genérico <code>doWith()</code> que pode ser usado 
	 para qualquer coisa. Embora o método não defina um retorno explicito, é possivel implementar uma outra classe
	 que implemente esta interface e permita o acesso a um resultado através de outro objeto.
	 Esse é o caso, por exemplo, de <code>NumberAcumulator</code> que extend <code>Acumulator</code> e implementa <code>Walker</code> 
	 e permite somar valores continos na coleção.
	 
	 <source>
	 	NumberAcumulator&lt;Real&gt; acumulator = NumberAcumulator.instance();
	 	
		Range range = Range.over(Real.valueOf(1), Real.valueOf(6),Real.ONE());
		// calcula a soma de 1 até 6
		range.each(acumulator);

		assertEquals(Real.valueOf(21), acumulator.getResult());
	 </source>
	 Aqui utilizámos a classe <code>Real</code> porque <code>NumberAcumulator</code> precisa de um objeto que implemente
	 a estrutura matemática <code>GroupAditive</code>. <code>Real</code> implementa uma forma especial de criar <code>Range</code>
	 O código ficaria assim:
	 <source>
	 	NumberAcumulator&lt;Real&gt; acumulator = NumberAcumulator.instance();
	 	
	 	// calcula a soma de 1 até 6
	 	Real.ONE().upTo(6).each(acumulator);
		
		assertEquals(Real.valueOf(21), acumulator.getResult());
		
	 </source>
	 Imprimir os numeros de 1 a 6 mostra um uso mais tradicional do <code>Walker</code>
	 <source>
	 Range.over(1,6).each(new Walker(){

		public void doWith(Integer it){

			System.out.println(it);

		}

	 });
	 </source>
	 Em java puro não teria muito ganho porque este Walker é muito simples. Mas se o Walker executar operações 
	 complexas (mais de 5 linhas)  escrever isso dentro de um for é  confuso.  colocando isso em uma objeto
	  é possivel definir a logia à parte e de forma genérica. Este é o objetivo, entre outros,  de trazer 
	  closures para Java. Segundo as tendencias qualquer interface poderia ser substituida por uma closure. 
	  Embora closures não venham na versão 7 do Java  é quase certo que virão em algum ponto. 
	  Enquanto não, as classe anónimas internas terão que servir.O ganho real viria da simplificação 
	  da sintaxe com o uso de Closures. Se um dia elas vierem vc poderia escrever assim:
	 <source>
		Range.over(1,6).each() {System.out.println(it) };
	 </source>
	 </p>
	 <p>
	 Um outro tipo de  <code>Walker</code> importante é aquele que caminha sobre uma arvore.
	 Para este tipo de objetos o MiddleHeaven introduz a interface <code>TreeWalkable</code> que extende 
	  <code>Walkable</code> com os métodos <code>eachRecursive()</code> e <code>eachParent()</code>. 
	 O método <code>eachRecursive</code> aplica o  <code>Walker</code> ao objeto, depois aos filhos 
	 e depois aos filhos dos filhos, etc.. 
	 O método eachParent() é aplicado ao pai do objeto corrente e depois ao dessse , assim até à raiz.
	 <code>TreeWalkable</code> é especialmente util para estruturas como o sistema de arquivos. 
	 <code>ManagedFile</code> da <a href="http://middleheaven.wordpress.com/toolboxes/managed-file-toolbox/">
	 Managed File Toolbox</a> implementa esta interface. 
	 </p>
	 </section>
	 <section name="Enumerable">
	 <p>
	 A classe utilitária <code>Collections</code> permite utilizar vários métodos sobre objetos que extendam <code>Collection</code>
	 ou <code>Map</code>. Isso é feito para que os mapas e coleções em Java não tenham que implementar um numero elevado de métodos
	 assim diminuindo a sua area de superfice. Isto é considerado uma boa prática. Contudo é estre,amente chato e inificiente
	 já que cada implementação não pode otimizar o processo definido pelo contrato do método. Além disso a chamada dos métodos
	 é pouco encadeável o que confunde os programadores iniciantes e frustra os experientes. 
	 </p>
	 <p>
	 Um outro problema com os mapas e coleções em java é a fala de uma interface comum para coleções e mapas.
	 </p>
	 <p>
	 O MiddleHeaven introduz a interface <code>Enumerable</code>  (enumerável). Esta interface serve dois propóstios: 1) o de prover uma interface
	 comum para mapas e coleções e extender o numero de métodos directamente invocáveis sobre os conjuntos.Um <code>Enumerable</code> é uma expanção do conceito de <code>Iterator</code>.  
	 Todos os <code>Enumerable</code> são <code>Iterator</code> mas têm mais coisas a oferecer. 
	 </p>
	 <p>
	 A maior parte dos métodos de <code>Enumerable</code> recebem implementações de <code>Classifier</code>. 
	 Este é um objeto que dado um objeto de um tipo retorna outro objeto do mesmo ou de outro tipo. 
	 Em particular pode retornar um objeto do tipo <code>Boolean</code>. A maior parte dos métodos de 
	 <code>Enumerable</code> usam classificadores para boolean excepto <code>map</code> que usa 
	 classificadores para qualquer outro objeto. O  objeto <code>Classifier</code> pode ser usado como 
	 filtro ou como transformador. Por exemplo, usando o método <code>find()</code> é possivel encontrar 
	 um objeto que passe no teste do classificador passado como argumento. Tudo isto sem ter que escrever
	 nenhuma instrução <code>for</code>.
	 </p>
	 <p>
	 <code>Enumerable</code> implementa <code>Walkable</code> e todas as operações com <code>Classifier</code> geram novos 
	 conjuntos após aplicar o classificador a todos os elementos
	 do ocnjunto. Os métodos que usam <code>Classifier</code> implementam o padrão Visitor de forma semelhante a <code>Walker</code>,
	 a diferença é que o resultado obtido pelo <code>Walker</code> não é convertido para um outro conjunto, enquanto que os que usam 
	 <code>Classifier</code> são.
	 </p>
	 <p>
	 Com isto o MiddleHeaven extende as interfaces <code>Collection</code>,<code>Set</code>, <code>List</code> e <code>Map</code>
	 implementando <code>Enumerable</code> e mais alguns métodos interessantes. Estes conjuntos são chamados de coleções aumentadas (enhanced) 
	 e implementam as interfaces <code>EnhancedCollection</code>, <code>EnhancedSet</code> , <code>EnhancedList</code> e <code>EnhancedMap</code> respectivamente. 
	 Para os obter basta invocar <code>CollectionUtils.enhance()</code>. O uso deste método é inivitável em Jaa devido ao fato
	 de não ser possivel adicionar este método nas interfaces já existentes. 
	 Criar uma coleção aumentada é muito simples:
	 <source>
	 List&lt;Integer&gt; lista = Arrays.asList(1,2,3,4,5,6); // lista na plataforma Java

	 EnhancedList&lt;Integer&gt; elista = CollectionUtils.enhance(lista);
	 
	 </source>
	 </p>
	 <p>
	 <code>Enumerable</code> permite enumerar e iterar sobre um conjunto em uma certa ordem. Mas e que tal
	 obter um elemento aleatóriamente de uma lista ou coleção ? O MiddleHeaven inclui a interface 
	 <code>RandomEnumerable</code>. Esta interface define o método <code>random()</code> que seleciona um elmento
	 aleatóriamente da coleção. Isso permite o sorteio de numeros em uma linha de codigo. 
	 Por exemplo para sortear os numeros de um dado fariamos:
	 <source>
	 Integer resultado = Range.over(1,6).random();
	 </source>
	 </p>
	 </section>
	 <section name="Porquê">
	 <p>
	 Muitos já tentaram criar bibliotecas alternativas para coleções. A Apache Commons Collections exisita mesmo antes
	 da API ser padrão na plataforma Java. Trabalhar com conjunto é realmente uma facilidade que permite ao mesmo tempo
	 tipagem forte, algoritmos eficientes e simplicidade para trabalhar com muitos objetos simultaneamente. O MiddleHeaven
	 não poderia,portante, se escusar que dar algum suporte a colleções.
	 </p>
	 <p>
	 Com o olho no Java 7 e a suposta introdução de closures, as coleções aumentadas teriam um uso mais simples e omnipresente
	 mas mesmo sem a funcionalidade de closures ha muita coisa que é mais facil de ser feita com o uso destas coleçoes.
	 Por outro lado, devido à necessidade de suportar intervalos (sobretudo os de tempo) era necessário introduzir 
	 classes diferentes mas de forma compativel. 
	 </p>
	 <p>
	 Converter qualquer conjunto da plataforma padrão para a biblioteca aumentada é muito simples. Aliás , à exceção de <code>EnhancedArrayList</code> 
	 que pode ser usada independente, aumentar uma coleção já exitente é a única forma de obter uma coleção aumentada.
	 </p>
	 <p>
	 [polldaddy poll=1615736]
	 </p>
	 </section>
	</body>
</document>
