<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<author>Sérgio Taborda</author>
		<title>Managed File</title>
	</properties>
	<body>
	<section name="Quantity and Measure: Time Toolbox">
		<p>
			The Time Toolbox is an expantion of the Quantity and Measure Toolbox in order to incorporate time related concepts and operations.
			This toolbox contains a representation API similar to Joda Time or JSR 310 but also includes new unifying concepts. 
		</p>
		<p>
			MiddleHeaven understands time as a continuum even thought most operations are discreet to the millisecond. This continuum is called the time line.
			The points in the line are called <code>TimePoint</code>s. <br/> Clocks do not measure time, they measure elapsed time : the "lenght" in the time line between two time points.
			<code>ElapsedTime</code> is, thus, the fundamental quantity for the Time Toolbox. The SI unit is the second. <br/>	
			Because no time point is special ( all have the same properties ) is required to 
			choose one specific point in the line and measure the time elapsed since then. This reference time point defines an Epoc. 
			(The point it self is often also called epoc). So when we say "year 2000" we mean "the time equivalent to the period elapsed since the epoc"
		    Different cultures choose different specific time points to start their evaluation of elapsed time. 
		    Those specific points are traditionally related to cultural events and together define the order of subsequent events in the time line. They define a certain <code>Chronology</code>.
		</p>
		<p>
			So, only time intervals can be measured , and thus quantified and related to units (second).
			Different cultures define different Epocs and Chronologies. Clocks measure the elapsed time.
			Underlying the concept of time is the concept of <i>current time</i>. The current time is defined as the time point indicated by a clock.
			In computation the current time is obtain from the machine clock by means of a call to some API method. In standard java <code>System.currentTimeMillis()</code>
			is used.
		</p>
		</section>
	<section name="Clocks">
		<p>
			Obtaining the current time directly with <code>System.currentTimeMillis()</code> is a problem. 
			When you need to test the application (e.g. unit test some class) you cannot wait until a certain time 
			to make the test. You need to control the concept of "current time". <br/>
			MiddleHeaven introduces the concept of Clock. A clock is an object capable of specifying the "current time".
		</p>
		<p>
			A <code>Clock</code> has three main properties:
			<ul>
			<li>Cadence - the rate as time "passes". The time in a "normal" clock elapses at a rate of 1 second per second. 
			defectuous clocks have different cadences and that is why they slow down or speed up. (General Relativity predicts different cadence when 
			a clock is inside a powerful gravitational field, MiddleHeaven's clock can be used to model this natural characteristic of nature).
			Providing clocks with different cadences with can simulate time events faster ,or slower, without having to wait for the real time period necessáry to the test.
			A task trigged every hour can thus be trigged every minute , second or day instead.
			</li>
			<li>TimeZone - not all clock in every city in the world show the same time. The differences are created by the geographic distance, relative position to the Sun apparent movement
			and also politic or economical convensions. Time in different clocks only can be related if a time zone is attached to each one. </li>
			<li>Current Time - last but not least, the current time it self.</li>
			</ul>
		</p>
		<p>
			MiddleHeaven comes with a variety of most common clocks. <code>MachineClock</code> is the one to use if you want to mimic <code>System.currentTimeMillis()</code>. 
			The time zone is default and cadence is 1. <code>StaticClock</code> is a clock with cadence 0 (means the time does not change). You can set any time point and time zone for it.
			Very useful for tests. <code>SpeedyClock</code> utilizes the real cadence of another underlying clock (pattern Decorator) and multiplies it by a configurable cadence factor.
			We SpeedyClock you can make time run faster, or slower. <code>SNTPUniversalTimeClock</code> is an experimental clock implementation whose propose is to always be in synch with an external time server.
			This can be very useful if you system is distributed so timestamp on events are meaningful.
		</p>
		<p>
			<code>AlarmClock</code>	is a special type of Clock that raises an event for a registred <code>ClockTickListener</code> on a certain <code>Schedule</code>.
			The mechanics of the clock can be obtain from any another clock implementation (pattern decorator), thus, you can run the AlarmClock normally embedding a MachineClock, or faster embedding a SpeedyClock.
			AlarmClock is used for work scheduling in the Work Toolbox and these mechanism allow for test in "not-real time" so you can test several work loads and cycles in an minimum amount of real test time.<br/>
		</p>
	</section>
	<section name="Chronology">
		<p>
		Once we have a clock and viable means to define "current time" we need to define the reference time frame. This is done by defining an epoc 
		and a Chronology. A Chonology is a sequence of reference events proper to a culture (or set of cultures) that permit the members of that culture 
		determine the position of events in the time line by mapping them to an elapsed time from the epoc. 
		</p>
		<p>
			<code>Chonology</code> encapsulates all calculation logic needed to the Time Toolbox. Different chronologies can be implement according to different
			cultures and rules. Also, chronologies can be implemented according to tecnologies.
		</p>
	</section>
	<section name="Model">
	
	</section>
	<section name="Under the Hood">
		<p>
		Work Scheduling can be achieved by an API such as <a href="http://www.opensymphony.com/quartz/">Quartz</a> or java standard or EE timers, however those API 
		are not compatible with the concept of "permutable clock" and only the machine clock can be used to schedule. Given that this is the real, production goal, but from
		a development point of view it lack testability. MiddleHeaven trade-off was then to prioritize extensability and testability over fancy, standard, production API.
		We will be back to this issue when we discuss the Work Toolbox.
		</p>	

	</section>
	</body>
</document>
