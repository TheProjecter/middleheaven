<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<author>SÃ©rgio Taborda</author>
		<title>Storage Toolbox</title>
	</properties>
	<body>
	<section name="Storage Toolbox">
		<p>
		Storage Toolbox concept is very simple: we need a toolbox to handle data preservation.
		By data preservation is meant persistance (store in hardcopy location) and/or prevaylance ( store in softcopy location).
		</p>
		<p>
		Data preservation is a common issue in enterprise systems. Historically data preservation was made 
		on hard disk, i.e. files. Files where not transactional and that implied in the need for data base management systems (DBMS).
		Nowadays systems interact with DBMS by means of SQL phases. The interaction is mediated by special software know as a Driver.
		Differente tecnologies exist for those Drivers. In java, the JDBC Drivers are used. Other tecnologies inclue de ODBC Drives and the ADO Drivers.
		</p>
		<p>
		Intracting with DBMS via SQL is not that simple. Each DBMS vendor incorporates special SQL sintax.
		These differences in the syntax create different SQL dialects. This is not good for the application programer. 
		If, on the other hand, you use only standar SQL sintax your program will not be benificing from the DBMs performance boost features
		</p>
		<p>
		Dependency on DBMS SQL dialects and features ( other that dialects , like procedures and triggers) really implies in short-lived
		applications.If you need to change to another DBMS product you cannot do it without the cost of reimplementing the DBMS 
		comunication layer (suposing you have one for starters. If do not, the cost will even higher). 
		</p>
		<p>
		The goal for the Storage Toolbox is to provide an abstraction layer that isolates all this problems from the application programer
		and application code.
		</p>
	</section>
	<section name="Data Storage">
		<p>
		The Storage Toolbox does not assume the data is stored in a DBMS. Today DBMS are commodyties and modern development tecniques
		hunger for more losse-ended data repositories. Two forces drive this choice. 1) a more unit testing oriented programming demands the storage features to be plugable in order
		to be replaced by strubs or mocks. 2) more RAM available at a lower cost enables aplications to performe better if the data objetcs 
		are mantained in memory for loger periods of time. This new aproach of transacional data repositories in RAM memory is being called prevaylance 
		and is know possible and competitive with the DBMS option. At the end of the day the data still needs to be stored in hardcopy repositories.
		but not destroing and creating object all the time from DBMS informations improves the over all aplication performance.   
		</p>
		<p>
		In memory data stores is realy very usefull for testing and development as it allows delaying the database design for later after you already defined and tested
		the data model. Also provides an intuitive option for object cache.
		</p>
		<p>
		A more modern aproch to data models take advantage of Object Oriented tecniques and isolates the developer from Table and Column searcing issues
		providing object search and edition tecniques instead.
		</p>
		<p>
		MiddleHeaven Storage Toolbox uses the concept of a logical <code>DataStorage</code> managed by a <code>StoreKeeper</code>
		Store keepers are mediatores for the real data preservance mechanics for either a DBMS, a XML file, a prevaylant system or a 
		commom in memory <code>List</code>.  MiddleHeaven Storage Toolbox provides total abstraction of the data preservance features. 
		</p>
	</section>
	<section name="Storing and Retriveing">
		<p>
		For every database system (managed or not) you always have set of basic operations you need. You need to be able to add new 
		data to the storage and have to be able to retrive data data. Further you commonly need to update the data already in storage.
		Finally you need to be able to delete de data in the storage (even thoguth deletion operations are considered armful as they may caracterize information destruction). 
		</p>
		<p>
		Java being a Object Oriented language all data needs to be place in objects, and we find two classifications of those objects: objects that contain only plain data ( liketext, data, logic values, numeric values)
		and objects that contains aggregations of the first objets. The first objects are classified as primtives ( as they are not composed) and the second are named data aggregates. In java, data agregates are ofen 
		objects with a Bean like contract ( a brunch of attributes with no further associated behavior other than read and write those attributes).   
		</p>
		<p>
		In a Object Oriented application is natural to use beans and primitives to represent data. And even further is natural to think that these beans are the data representations of our application
		entities. MiddleHeaven Storage Tooblox, thus, choses to manipulate these beans and primitives directly and not to expose to the programer the real storage structures (either tables, or maps, etc.)
		</p>
		<p>
		When retriving the data from a data storage is ofen possible to retrive the same data for different porpuses. Normally a query based aproach is used. 
		DBMS use SQL phases to build those queries but from a Object Oriented and a Java prespective, SQL is a pour aproach. SQL is not OO and it is really more used like a protocol
		that as a query object (even thought it is one).  
		</p>
		<p>
		The MiddleHeaven Storage Toolbox choses to use object oriented strutures - named Criteria - to provide this query object feature. SQL or any other "protocol"-like query language ( like XPath or XQuery , for XML) 
		is not used by the programamer. Instead, those languages are used by the <code>StoreKeeper</code> in order to comunicate with the underlying  data storage. 
		What this really means is that you will program your aplication to talk to a DataStorage and that's it. If you later decide to change the keeper (i.e. the underlying storage technology) you simply can.
		</p>
	</section>
	<section name="Something about entities">
		<p>
		What is an entity ? An entity is something whose instances have Identity. Identity is a intrinsic property that is diferent for each  entity's instance (i.e. each instance has its own identity).
		Think on a persons identity. Wich property you will use as Identity ? The right awnser is: none. None of the properties that caracterize a person (height, eye color, finger prints, DNA) are the persons identity.
		Some, are closly related like DNA and finger prints, but, they are only realted, they are not the identity of a person it self. So, identity is something abstract. Mathematics is almost solenely based on the concept of identity.
		When you wright <i>2 = 3</i> it means "the identity of 2 is the same as the identity of 3". ( This is false because identity is , by definition, different for each number.)
		</p>
		<p>
		In Java all objects have identity. Each object is diferent from the other object. You can assert and compare identity with the == operator ( = is the assignement operator, not the assert identity operator).
		However this JVM inforced identity is to strong for enterprise application porpuses. You need a identity that you can define and compare. This means you must allow to have two or more object that are not the same and still
		represent the same instance of the entity, i.e. they share a commom identity.
		</p>
		<p>
		Accross history several informations about an entity have been used to harness/simulate identity. Names and identification numbers
		are the msot common. However, today, the best property you can use is a property with no meaning, i.e. a "virtual" property that you create 
		specially to decide about the equalness of the identity. Normally an integer number sufices, even thought some times you need a Universal Unique Identifier (<wiki>UUID</wiki>)   
		</p>
		<p>
		MiddleHeaven Storage Toolbox use the <code>Identity</code> type as an abstraction for the identity property. Implementations can then chose a sutable implementation of Identity
		according to the entity at hand.  
		</p>
	</section>
	<section name="Model">
		<p>
		<center>
		<a href="images/ilustrations/storage.png" target="_top">
<img src="images/ilustrations/thumb_storage.png" class="pictureframe"/>
</a>
		</center>
		The MiddleHeaven Storage Toolbox implemnts a agnostic domain store. This means it is not limited to DBMS queries but can be used with other
		tecnologies that could be used to create databases e.g. XML.
		</p>
		<p> 
		The main type are the <code>DataStorage</code> , <code>Criteria</code> and <code>Query</code> interfaces. 
		<code>DataStorage</code> allows for interation with the data storage.  <code>Criteria</code> objects are implementations for the Query Obejct pattern
		and  can be used to specify complex queries. The <code>DataStorage</code> will convert them into  <code>Query</code> objects that represent the query results.
		Nothinmg is said about at what moment the query is really performed on the datastorage. By design the query should only be perform when one on the Query methods is invoqued.
		</p>
		<p>
		Extra information about how the query should behave can be passed as second parameter. This hints inform the datastorage how the data will be read and this
		allows for otimization by using patterns like Fastlane Reader or Flyweight.  
		</p>
		<p>
		<code>Criteria</code> objects can be build by the programmer but the <code>CriteriaBuilder</code> class provides a fluent interface for this task. Also, using the  <code>CriteriaBuilder</code>
		you end up with code that closely resembles a SQL query, being easy to read and change, but the advantage of strong typing.
		<code>Criteria</code> objects are created by invoking the searc method on the criteriaBuilder. You can use static import to further simplify the query as showned here:
		<pre name="source" class="java">
		Criteria&lt;Subject&gt; someCriteria = search(Subject.class)
		.and("name").not().eq("Jack")
		.orderBy("name").asc()
		.all();
		</pre> 
		</p>
		<section name="StoreKeeper">
			<p>
			All <code>DataStorage</code> operations are really delegated to a <code>StoreKeeper</code>. <code>StoreKeeper</code> is responsabile to really change or retrive the data from
			the real data sotrage. MiddleHeaven now implements the <code>DataBaseStorageKeeper</code> for access to DBMS via JDBC, a <code>XMLStorageKeeper</code> and a InMemoryStorageKeeper. At this point both
			this storekeepers are being explored in order to obtain a agnostic enought model for the keeppers across diferente data preservation APIs. 
			</p>
			<p>
			The <code>DataBaseStorageKeeper</code> goal is to able to comunicate with any DBMS. In order to acomodate several diferent dialects a <code>DatabaseDialect</code> type was introduced.
			It performs all the SQL/JDBC related operations including the generation of SQL statements.  <code>DatabaseDialect</code> encapsulates he creation of comands for most of the SQL standard operations, including creating tables 
			and reading and changing the database model. The <code>DataBaseStorageKeeper</code> obtains the comands form the dialect and then performs the operations in a DBMS independent way.
			Out-of-the box, at the time this is being writen, MiddleHeaven Storage Toolbox supports PostgreSQL 8.3, HSQL 1.8 and SQL Server 2005 dialects.  
			<code>DataBaseStorageKeeper</code> uses a Datasource from were to obtain <code>javax.sql.Connection</code>.
			</p>
			<p>
			None of the <code>StorageKeeper</code>s performs any transacional control. However, if the underlying storage is not transactional it may help to support integeration with 
			the Trasnacional Toolbox.
			</p>
		</section>
		<section name="Storable and StorableEntityModel">
			<p>
			<code>StoreKeeper</code> handles collections of <code>Storable</code>s. Each object passed to the DataStorage is converted to a <code>Storable</code>
			before being passed to the keeper. <code>Storable</code>s allow for control of persistance properties of the object other than the data provieded by the object.
			The fields and values of the storable are abstracted by a <code>StorableFieldModel</code>. The set of all fields' <code>StorableFieldModel</code>s form the <code>StorableEntityModel</code> for the entity.
			<code>StorableEntityModel</code> is a agnostic abstraction for the entity from the keeper point of view. For now a simple implementations based on the <ocde>StorableDomainModel</ocde> is provided.
			The rational is that the persistance model for the entity is conceptualy decopled from entity model it-self. The goal is to provided the means to implements complex multiplicity relations between 
			entities and the underlying data structures ( tables, files, etc...) thus not realying on a simples one-to-one relation multiplicity.
			</p>
			<p>
			The model also acts as a factory for entity instances. This is essencial to mapping and loading new data objects from the underlying data.
			</p>
		</section>
	</section>
	<section name="Under the hood">
	  <p>
	  MiddleHeaven's Storage Toolbox is an agnostic Domain Store pattern implementation. Some API already support this patterns like JPA and Hibernate.
	  Conceptually is possible to implement a StoreKeeper to use those API, however they are extremmly focusses on SQL and DBMS making direct use of concepts 
	  like Table , Primary Key and Automatic Key Generation. DataStorages also have key (identity) generation but is totally decouple from the DBMS.
	  For exemple, when the DBMS nativly supports sequences, the keeper can return an encaspulation of that on a <code>Sequence</code> object.
	  When not, the keeper can simulate the sequence by other means.   
	  </p>
	  <p>
	  On the other hand MiddleHeaven's Storage Toolbox lacks meny of the otimizations performed by Hibernate or JPA, like genrational cache. MiddleHeaven's Storage Toolbox 
	  is designed to be able to provide the same funcionality by decorating (Decorator Pattern) dataStorages with other datastorages enabling the application to use a cached version of any 
	  other underlying data storage. This is still a work in progress at this moment.  
	  </p>
	  <p>
	  The trade-off for this toolbox was not to depend on any other API has none of the available is agnostic enought. This implies in a grater efford to
	  implement and test the tooblox, but provides greater flexibelity.  
	  </p>
	  <p>
	  <code>Storable</code> is an internal type used to control persistance state. Any object passed to the <ocde>DataStorage</ocde> is converted in a Storable.
	  this is achived by means of bytecode manipulation allowing the original object to be mutated to an object that extends the original classe and implements the <code>Storable</code> interface.
	  This is one of the reason why the store method returns an object of the same type. This object is not the same object passed to the method, it's now a managed object.
	  If this object is further used and changed by the aplication those alterations are recorded. When the object is again passed to the store method the data storage 
	  can identify the changes and act acoordigly. If, for exemple, no changes where made, the method will simply return. Also, any object returned by the <code>Query</code> interface is a managed object, 
	  by the same reasons.    
	  </p>
	</section>
	<section name="Limitations">
		<p>
		As the MiddleHeaven Storage Toolbox is based on entity objects there is less room to work with the storage native data elements themselfs. 
		Meaning that you are not suposed to work with tables , columns , rows or xml directly. For that kind of interaction you will use other 
		tecnologies and toolboxes ( some of wich are used internally by the implementation). 
		</p>
		<p>
		A second limitation is that , for now, only a Domain Driven Datastorage is provided. Even thought the structure does limit this design
		this is the most usefull implementation nowadays. Support for an <i>ad doc</i> datastorage could be implemented in the future according to demand.
		</p>
	</section> 
	</body>
</document>
