<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<body>
<body>
	<h2>Utilitátios</h2>
	<p align="justify">
	A plataforma java oferece uma vasto suporte ao 
	<a href="http://sergiotaborda.wordpress.com/java/colecoes-em-java/" target="_new">
	conceito de conjuntos</a> (coleções e mapas), mas não tão vasto quanto 
	poderia ser. 
	</p>
	<p align="justify">
	A limitação à API de coleções atual é o uso da classe Colections para 
	coisas avanaçadas como ordenação e a falta de suporte a Closures pelo 
	Java. Mesmo se o Java tivesse suporte, depois das discussões para o Java 7 -
	a closures não ha garantia de que a API de coleções seria alterada.
	</p>
	<p align="justify">
	Mesmo com o suporte a coleções da plataforma falta suporte a outras estruturas 
	- que não sendo coleções - estão relacionadas a teoria de conjuntos como 
	intervalos.
	</p>
	
	<h2>Intervalo</h2>
	<p align="justify">
	O MiddleHeaven dá suporta a intervalos pela classe <font face="courier">Interval</font> definida 
	conjunto de elementos ordenável. Elemento ordenável é todo aquele que implements <font face="courier">Comparable</font>
	ou a que se possa associar um <font face="courier">Comparator</font>.
	Um intervalo pode ser fechado ( tem principio e fim) , aberto ( sem principio
	ou sem fim) ou vazio ( o principio e o fim são iguais). 
	</p>
	<p align="justify">
	A classe <font face="courier">Interval</font> suporta várias operações que podem ser feitas 
	sobre ou com intervalos, tais como interseção, união ou verificar se um elemento 
	está no intervalo. 
	</p>
	<p align="justify">
	Era importante incluir conceito de intervalo. Isso é especialmente relevante 
	o dominio de tempos e datas (<a href="http://middleheaven.wordpress.com/toolboxes/quantidades-e-medidas/time-toolbox/" target="_new">Time Toolbox</a>)
	onde é comum definir intervalos de tempo. O MiddleHeaven define <font face="courier">TimeInterval</font> 
	como uma extensão de <font face="courier">Interval</font> aplicada a <font face="courier">TimePoint</font> 
	e adiciona operações relacionadas a tempo como a conversão para <font face="courier">Period</font>
	</p>
	
	<h2>Range</h2>
	<p align="justify">
	Um intervalo não é iterável porque ele pode ser aberto. Para ter um objeto semelhante a um intervalo 
	mas que é iterável temos o <font face="courier">Range</font>. O objeto <font face="courier">Range</font> parece-se muito com um intervalo, 
	mas podemos iterar os elementos através de um <font face="courier">Incrementator</font>.  
	Um incrementador permite passar de um elemento ao próximo de uma forma controlada. Por exemplo,
	para passar de 1 a 2 adicionamos 1, mas para passar de 2009-09-10 a 2009-09-11 temos que obter a proxima data.
	Não podemos simplesmente adicionar 1.
	</p>
	<p align="justify"> 
    O incrementador é especialmente relevante para elementos de um conjunto ordenável e denso como os numeros reais, já que para estes tipos 
    de conjunto não podemos determinar qual é o proximo elemento a partir de um elemento dado. 
    Por exemplo, nos numeros reais, a seguir a 1 existe um numero, mas não é 2, nem 1.5, nem 1.1, 
    nem 1.0000001 , nem ... Por causa desta impossibilidade matemática, ao criar um <font face="courier">Range</font> sobre um 
    conjunto denso é necessário estabelecer o passo através de um incrementador. Por exemplo de 1 em 1, poderiamos
    iterar de 2 a 5 e teriamos [2, 3 ,4, 5] , mas como passo de 0.5 teriamos [2, 2.5 , 3 , 3.5 , 4 , 4.5 , 5].
	</p>
	
	<h2>Caminhando sobre o conjunto</h2>
	<p align="justify">
	A API de collections é muito boa usando o padrão Iterator ( um dos padrões GoF) mas falha usando o 
	padrão Visitor (também do GoF) . O padrão visitor é muito util para fazer passar um objeto por todos 
	os elementos da coleção.  Assim, a coleção recebe um objeto que visita todos os elementos para um 
	determinado fim. O padrão visitor é muito util porque esconde a iteração do for ou do while e 
	desta maneira deixa a coleção fazer a caminhada pelos elementos como ela quiser ( em tese da forma mais eficiente).  
	O padrão Visitor é aquele que seria utilzado por closures, caso elas existissem para aplicar uma certa logica
	a cada elementos do conjunto. O MiddleHeaven suporta o conceito por detrás do padrão visitor e introduz as 
	interfaces <font face="courier">Walkable</font> e <font face="courier">Walker</font>. Um <font face="courier">Walkable</font> é um objeto que pode 
	ser "caminhado" por um "caminhante" (<font face="courier">Walker</font>) em analogia a que um objeto  <font face="courier">Iterable</font> pode ser iterado
	através de um <font face="courier">Iterator</font>.  
	</p>
	<p align="justify">
	 A interface <font face="courier">Walker</font> apenas define um método genérico <font face="courier">doWith()</font> que pode ser usado 
	 para qualquer coisa. Embora o método não defina um retorno explicito, é possivel implementar uma outra classe
	 que implemente esta interface e permita o acesso a um resultado através de outro objeto.
	 Esse é o caso, por exemplo, de <font face="courier">NumberAcumulator</font> que extend <font face="courier">Acumulator</font> e implementa <font face="courier">Walker</font> 
	 e permite somar valores continos na coleção.
	 
	 <table align="center" border="0">
<tr align="center">
<td>
<source>





<div align="left" class="java">
<table bgcolor="#ffffff" border="0" cellpadding="3" cellspacing="0">
   <tr>
  
   <td align="left" nowrap="nowrap" valign="top">
    
<font color="#808080">1</font> <font color="#ffffff"/>
<br/>
<font color="#808080">2</font> <font color="#ffffff">     </font>
<font color="#000000">NumberAcumulator&lt;Real&gt; acumulator = NumberAcumulator.instance</font>
<font color="#000000">()</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">3</font> <font color="#ffffff">     </font>
<br/>
<font color="#808080">4</font> <font color="#ffffff">    </font>
<font color="#000000">Range range = Range.over</font>
<font color="#000000">(</font>
<font color="#000000">Real.valueOf</font>
<font color="#000000">(</font>
<font color="#990000">1</font>
<font color="#000000">)</font>
<font color="#000000">, Real.valueOf</font>
<font color="#000000">(</font>
<font color="#990000">6</font>
<font color="#000000">)</font>
<font color="#000000">,Real.ONE</font>
<font color="#000000">())</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">5</font> <font color="#ffffff">    </font>
<font color="#008000">// calcula a soma de 1 até 6</font>
<br/>
<font color="#808080">6</font> <font color="#ffffff">    </font>
<font color="#000000">range.each</font>
<font color="#000000">(</font>
<font color="#000000">acumulator</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">7</font> <font color="#ffffff"/>
<br/>
<font color="#808080">8</font> <font color="#ffffff">    </font>
<font color="#000000">assertEquals</font>
<font color="#000000">(</font>
<font color="#000000">Real.valueOf</font>
<font color="#000000">(</font>
<font color="#990000">21</font>
<font color="#000000">)</font>
<font color="#000000">, acumulator.getResult</font>
<font color="#000000">())</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">9</font> <font color="#ffffff">   </font>
    
   </td>
  
   </tr>
</table>
</div>



</source>
</td>
</tr>
<tr>
<td class="legend">
<hr/>
		Código 1: </td>
</tr>
</table>
	 Aqui utilizámos a classe <font face="courier">Real</font> porque <font face="courier">NumberAcumulator</font> precisa de um objeto que implemente
	 a estrutura matemática <font face="courier">GroupAditive</font>. <font face="courier">Real</font> implementa uma forma especial de criar <font face="courier">Range</font>
	 O código ficaria assim:
	 <table align="center" border="0">
<tr align="center">
<td>
<source>





<div align="left" class="java">
<table bgcolor="#ffffff" border="0" cellpadding="3" cellspacing="0">
   <tr>
  
   <td align="left" nowrap="nowrap" valign="top">
    
<font color="#808080">1</font> <font color="#ffffff"/>
<br/>
<font color="#808080">2</font> <font color="#ffffff">     </font>
<font color="#000000">NumberAcumulator&lt;Real&gt; acumulator = NumberAcumulator.instance</font>
<font color="#000000">()</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">3</font> <font color="#ffffff">     </font>
<br/>
<font color="#808080">4</font> <font color="#ffffff">     </font>
<font color="#008000">// calcula a soma de 1 até 6</font>
<br/>
<font color="#808080">5</font> <font color="#ffffff">     </font>
<font color="#000000">Real.ONE</font>
<font color="#000000">()</font>
<font color="#000000">.upTo</font>
<font color="#000000">(</font>
<font color="#990000">6</font>
<font color="#000000">)</font>
<font color="#000000">.each</font>
<font color="#000000">(</font>
<font color="#000000">acumulator</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">6</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">7</font> <font color="#ffffff">    </font>
<font color="#000000">assertEquals</font>
<font color="#000000">(</font>
<font color="#000000">Real.valueOf</font>
<font color="#000000">(</font>
<font color="#990000">21</font>
<font color="#000000">)</font>
<font color="#000000">, acumulator.getResult</font>
<font color="#000000">())</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">8</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">9</font> <font color="#ffffff">   </font>
    
   </td>
  
   </tr>
</table>
</div>



</source>
</td>
</tr>
<tr>
<td class="legend">
<hr/>
		Código 2: </td>
</tr>
</table>
	 Imprimir os numeros de 1 a 6 mostra um uso mais tradicional do <font face="courier">Walker</font>
	 <table align="center" border="0">
<tr align="center">
<td>
<source>





<div align="left" class="java">
<table bgcolor="#ffffff" border="0" cellpadding="3" cellspacing="0">
   <tr>
  
   <td align="left" nowrap="nowrap" valign="top">
    
<font color="#808080">01</font> <font color="#ffffff"/>
<br/>
<font color="#808080">02</font> <font color="#ffffff">   </font>
<font color="#000000">Range.over</font>
<font color="#000000">(</font>
<font color="#990000">1</font>
<font color="#000000">,</font>
<font color="#990000">6</font>
<font color="#000000">)</font>
<font color="#000000">.each</font>
<font color="#000000">(</font>
<font color="#0000c0">
<b>new </b>
</font>
<font color="#000000">Walker</font>
<font color="#000000">(){</font>
<br/>
<font color="#808080">03</font> <font color="#ffffff"/>
<br/>
<font color="#808080">04</font> <font color="#ffffff">    </font>
<font color="#0000c0">
<b>public </b>
</font>
<font color="#c00000">
<b>void </b>
</font>
<font color="#000000">doWith</font>
<font color="#000000">(</font>
<font color="#000000">Integer it</font>
<font color="#000000">){</font>
<br/>
<font color="#808080">05</font> <font color="#ffffff"/>
<br/>
<font color="#808080">06</font> <font color="#ffffff">      </font>
<font color="#000000">System.out.println</font>
<font color="#000000">(</font>
<font color="#000000">it</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">07</font> <font color="#ffffff"/>
<br/>
<font color="#808080">08</font> <font color="#ffffff">    </font>
<font color="#000000">}</font>
<br/>
<font color="#808080">09</font> <font color="#ffffff"/>
<br/>
<font color="#808080">10</font> <font color="#ffffff">   </font>
<font color="#000000">})</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">11</font> <font color="#ffffff">   </font>
    
   </td>
  
   </tr>
</table>
</div>



</source>
</td>
</tr>
<tr>
<td class="legend">
<hr/>
		Código 3: </td>
</tr>
</table>
	 Em java puro não teria muito ganho porque este Walker é muito simples. Mas se o Walker executar operações 
	 complexas (mais de 5 linhas)  escrever isso dentro de um for é  confuso.  colocando isso em uma objeto
	  é possivel definir a logia à parte e de forma genérica. Este é o objetivo, entre outros,  de trazer 
	  closures para Java. Segundo as tendencias qualquer interface poderia ser substituida por uma closure. 
	  Embora closures não venham na versão 7 do Java  é quase certo que virão em algum ponto. 
	  Enquanto não, as classe anónimas internas terão que servir.O ganho real viria da simplificação 
	  da sintaxe com o uso de Closures. Se um dia elas vierem vc poderia escrever assim:
	 <table align="center" border="0">
<tr align="center">
<td>
<source>





<div align="left" class="java">
<table bgcolor="#ffffff" border="0" cellpadding="3" cellspacing="0">
   <tr>
  
   <td align="left" nowrap="nowrap" valign="top">
    
<font color="#808080">1</font> <font color="#ffffff"/>
<br/>
<font color="#808080">2</font> <font color="#ffffff">    </font>
<font color="#000000">Range.over</font>
<font color="#000000">(</font>
<font color="#990000">1</font>
<font color="#000000">,</font>
<font color="#990000">6</font>
<font color="#000000">)</font>
<font color="#000000">.each</font>
<font color="#000000">() {</font>
<font color="#000000">System.out.println</font>
<font color="#000000">(</font>
<font color="#000000">it</font>
<font color="#000000">) }</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">3</font> <font color="#ffffff">   </font>
    
   </td>
  
   </tr>
</table>
</div>



</source>
</td>
</tr>
<tr>
<td class="legend">
<hr/>
		Código 4: </td>
</tr>
</table>
	 </p>
	 <p align="justify">
	 Um outro tipo de  <font face="courier">Walker</font> importante é aquele que caminha sobre uma arvore.
	 Para este tipo de objetos o MiddleHeaven introduz a interface <font face="courier">TreeWalkable</font> que extende 
	  <font face="courier">Walkable</font> com os métodos <font face="courier">eachRecursive()</font> e <font face="courier">eachParent()</font>. 
	 O método <font face="courier">eachRecursive</font> aplica o  <font face="courier">Walker</font> ao objeto, depois aos filhos 
	 e depois aos filhos dos filhos, etc.. 
	 O método eachParent() é aplicado ao pai do objeto corrente e depois ao dessse , assim até à raiz.
	 <font face="courier">TreeWalkable</font> é especialmente util para estruturas como o sistema de arquivos. 
	 <font face="courier">ManagedFile</font> da <a href="http://middleheaven.wordpress.com/toolboxes/managed-file-toolbox/" target="_new">
	 Managed File Toolbox</a> implementa esta interface. 
	 </p>
	 
	 <h2>Enumerable</h2>
	 <p align="justify">
	 A classe utilitária <font face="courier">Collections</font> permite utilizar vários métodos sobre objetos que extendam <font face="courier">Collection</font>
	 ou <font face="courier">Map</font>. Isso é feito para que os mapas e coleções em Java não tenham que implementar um numero elevado de métodos
	 assim diminuindo a sua area de superfice. Isto é considerado uma boa prática. Contudo é estre,amente chato e inificiente
	 já que cada implementação não pode otimizar o processo definido pelo contrato do método. Além disso a chamada dos métodos
	 é pouco encadeável o que confunde os programadores iniciantes e frustra os experientes. 
	 </p>
	 <p align="justify">
	 Um outro problema com os mapas e coleções em java é a fala de uma interface comum para coleções e mapas.
	 </p>
	 <p align="justify">
	 O MiddleHeaven introduz a interface <font face="courier">Enumerable</font>  (enumerável). Esta interface serve dois propóstios: 1) o de prover uma interface
	 comum para mapas e coleções e extender o numero de métodos directamente invocáveis sobre os conjuntos.Um <font face="courier">Enumerable</font> é uma expanção do conceito de <font face="courier">Iterator</font>.  
	 Todos os <font face="courier">Enumerable</font> são <font face="courier">Iterator</font> mas têm mais coisas a oferecer. 
	 </p>
	 <p align="justify">
	 A maior parte dos métodos de <font face="courier">Enumerable</font> recebem implementações de <font face="courier">Classifier</font>. 
	 Este é um objeto que dado um objeto de um tipo retorna outro objeto do mesmo ou de outro tipo. 
	 Em particular pode retornar um objeto do tipo <font face="courier">Boolean</font>. A maior parte dos métodos de 
	 <font face="courier">Enumerable</font> usam classificadores para boolean excepto <font face="courier">map</font> que usa 
	 classificadores para qualquer outro objeto. O  objeto <font face="courier">Classifier</font> pode ser usado como 
	 filtro ou como transformador. Por exemplo, usando o método <font face="courier">find()</font> é possivel encontrar 
	 um objeto que passe no teste do classificador passado como argumento. Tudo isto sem ter que escrever
	 nenhuma instrução <font face="courier">for</font>.
	 </p>
	 <p align="justify">
	 <font face="courier">Enumerable</font> implementa <font face="courier">Walkable</font> e todas as operações com <font face="courier">Classifier</font> geram novos 
	 conjuntos após aplicar o classificador a todos os elementos
	 do ocnjunto. Os métodos que usam <font face="courier">Classifier</font> implementam o padrão Visitor de forma semelhante a <font face="courier">Walker</font>,
	 a diferença é que o resultado obtido pelo <font face="courier">Walker</font> não é convertido para um outro conjunto, enquanto que os que usam 
	 <font face="courier">Classifier</font> são.
	 </p>
	 <p align="justify">
	 Com isto o MiddleHeaven extende as interfaces <font face="courier">Collection</font>,<font face="courier">Set</font>, <font face="courier">List</font> e <font face="courier">Map</font>
	 implementando <font face="courier">Enumerable</font> e mais alguns métodos interessantes. Estes conjuntos são chamados de coleções aumentadas (enhanced) 
	 e implementam as interfaces <font face="courier">EnhancedCollection</font>, <font face="courier">EnhancedSet</font> , <font face="courier">EnhancedList</font> e <font face="courier">EnhancedMap</font> respectivamente. 
	 Para os obter basta invocar <font face="courier">CollectionUtils.enhance()</font>. O uso deste método é inivitável em Jaa devido ao fato
	 de não ser possivel adicionar este método nas interfaces já existentes. 
	 Criar uma coleção aumentada é muito simples:
	 <table align="center" border="0">
<tr align="center">
<td>
<source>





<div align="left" class="java">
<table bgcolor="#ffffff" border="0" cellpadding="3" cellspacing="0">
   <tr>
  
   <td align="left" nowrap="nowrap" valign="top">
    
<font color="#808080">1</font> <font color="#ffffff"/>
<br/>
<font color="#808080">2</font> <font color="#ffffff">   </font>
<font color="#000000">List&lt;Integer&gt; lista = Arrays.asList</font>
<font color="#000000">(</font>
<font color="#990000">1</font>
<font color="#000000">,</font>
<font color="#990000">2</font>
<font color="#000000">,</font>
<font color="#990000">3</font>
<font color="#000000">,</font>
<font color="#990000">4</font>
<font color="#000000">,</font>
<font color="#990000">5</font>
<font color="#000000">,</font>
<font color="#990000">6</font>
<font color="#000000">)</font>
<font color="#000000">; </font>
<font color="#008000">// lista na plataforma Java</font>
<br/>
<font color="#808080">3</font> <font color="#ffffff"/>
<br/>
<font color="#808080">4</font> <font color="#ffffff">   </font>
<font color="#000000">EnhancedList&lt;Integer&gt; elista = CollectionUtils.enhance</font>
<font color="#000000">(</font>
<font color="#000000">lista</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">5</font> <font color="#ffffff">   </font>
<br/>
<font color="#808080">6</font> <font color="#ffffff">   </font>
    
   </td>
  
   </tr>
</table>
</div>



</source>
</td>
</tr>
<tr>
<td class="legend">
<hr/>
		Código 5: </td>
</tr>
</table>
	 </p>
	 <p align="justify">
	 <font face="courier">Enumerable</font> permite enumerar e iterar sobre um conjunto em uma certa ordem. Mas e que tal
	 obter um elemento aleatóriamente de uma lista ou coleção ? O MiddleHeaven inclui a interface 
	 <font face="courier">RandomEnumerable</font>. Esta interface define o método <font face="courier">random()</font> que seleciona um elmento
	 aleatóriamente da coleção. Isso permite o sorteio de numeros em uma linha de codigo. 
	 Por exemplo para sortear os numeros de um dado fariamos:
	 <table align="center" border="0">
<tr align="center">
<td>
<source>





<div align="left" class="java">
<table bgcolor="#ffffff" border="0" cellpadding="3" cellspacing="0">
   <tr>
  
   <td align="left" nowrap="nowrap" valign="top">
    
<font color="#808080">1</font> <font color="#ffffff"/>
<br/>
<font color="#808080">2</font> <font color="#ffffff">   </font>
<font color="#000000">Integer resultado = Range.over</font>
<font color="#000000">(</font>
<font color="#990000">1</font>
<font color="#000000">,</font>
<font color="#990000">6</font>
<font color="#000000">)</font>
<font color="#000000">.random</font>
<font color="#000000">()</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">3</font> <font color="#ffffff">   </font>
    
   </td>
  
   </tr>
</table>
</div>



</source>
</td>
</tr>
<tr>
<td class="legend">
<hr/>
		Código 6: </td>
</tr>
</table>
	 </p>
	 
	 <h2>Porquê</h2>
	 <p align="justify">
	 Muitos já tentaram criar bibliotecas alternativas para coleções. A Apache Commons Collections exisita mesmo antes
	 da API ser padrão na plataforma Java. Trabalhar com conjunto é realmente uma facilidade que permite ao mesmo tempo
	 tipagem forte, algoritmos eficientes e simplicidade para trabalhar com muitos objetos simultaneamente. O MiddleHeaven
	 não poderia,portante, se escusar que dar algum suporte a colleções.
	 </p>
	 <p align="justify">
	 Com o olho no Java 7 e a suposta introdução de closures, as coleções aumentadas teriam um uso mais simples e omnipresente
	 mas mesmo sem a funcionalidade de closures ha muita coisa que é mais facil de ser feita com o uso destas coleçoes.
	 Por outro lado, devido à necessidade de suportar intervalos (sobretudo os de tempo) era necessário introduzir 
	 classes diferentes mas de forma compativel. 
	 </p>
	 <p align="justify">
	 Converter qualquer conjunto da plataforma padrão para a biblioteca aumentada é muito simples. Aliás , à exceção de <font face="courier">EnhancedArrayList</font> 
	 que pode ser usada independente, aumentar uma coleção já exitente é a única forma de obter uma coleção aumentada.
	 </p>
	 <p align="justify">
	 [polldaddy poll=1615736]
	 </p>
	 
	</body>
<h2>Licença</h2>
<table align="center" width="70%">
<tr>
<td align="center" valign="center">
<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" rel="license">
<img alt="Creative Commons License" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" style="border-width:0"/>
</a>
</td>
<td align="left" valign="top">  Sérgio Taborda<br/>
				      Este trabalho é licenciado sob a <br/>
<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.pt" rel="license" target="_new">
						Licença Creative Commons Atribuição-Uso Não-Comercial-Não a obras derivadas 3.0 Genérica
						</a>.
						
				      </td>
</tr>
</table>
</body>
