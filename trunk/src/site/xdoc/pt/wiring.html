<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<body>
<body>
	<h2>Wiring Toolbox</h2>
	<p align="justify">
	A toolbox de injeção automática de dependências  do MiddleHaven é chamado Wiring Toolbox.
	</p>
	<p align="justify">O conceito de injeção automática de dependências já é bastante conhecido graças a frameworks 
	como o PicoContainer e o Spring. Recentemente este conceito foi incluído na especificação EJB 3.0.
	O conceito, é simples; um objecto de uma certa classe normalmente precisa de objetos de outras 
	classes para funcionar. Isso cria uma dependência entre eles.  
	Normalmente esta dependência é satisfeita passando uma instancia do objecto, manualmente, 
	no construtor ou num método modificador (um método set). 
	Este ato de atribuir as dependências ao objeto é conhecido como injeção ou wiring ("unir com fiação"). 
	O nome "injeção" estabelece que ha um objeto injetado, um injetando e um objecto injetor. 
	O nome "wiring" estabelece a ideia de dois objetos que são associados.  
	Na prática ambos dão o mesmo resultado e trata-se apenas de uma diferença na nomenclatura.
	</p>
	<p align="justify">
	A ideia da injeção automática é que seja o sistema a descobrir e instanciar o objeto certo em runtime 
	e não o programador em tempo de codificação. Isto porque, a injeção manual leva ao uso de padrões de 
	projeto como <b>Factory</b> e <b>ServiceLocator</b> que usados em demasia 
	tornam o codigo dificil de manter já que a injeção não está centralizada e pior que isso, 
	é controlada pelo proprio objeto que precisa das dependencias. 
	Ele assume responsabilidade de saber e encontrar as suas dependencias e isso viola o 
	<principle>Principio de Inversão de Controle</principle> (IoC).
	</p>
	<p align="justify">  
	Para que o sistema sera OO e respeite o<principle>Principio de Inversão de Controle</principle> precisamos 
	de um outro objeto que controle a injeção das dependencias : o injetor.
	</p>
	<p align="justify">
	O MiddleHeaven usa os termos "wiring" e "wire" em vez de injeção. Para o MiddleHeaven o Injetor é uma peça fundamental
	mas que funciona por detrás dos panos. Não existe uma classe "injetor" e o programador final não mexe diretamente com ele.
	</p>
	
	<h2>Arquitetura</h2>
	<p align="justify">
	Um sistema de Injeção Automática de Dependência é composto por várias partes. 
	O controlador do processo normalmente chamado de Injetor é a parte que sabe como procurar as 
	dependências e injetá-las. No MiddleHeaven o injetor está escondido e o papel de fornecer acesso às suas funcionalidades
	case ao <font face="courier">WiringService</font>. O <font face="courier">WiringService</font> é o serviço central da Wiring Toolbox.
	</p>
	<p align="justify">
	Se os objetos já existem em outros contextos  ( por exemplo, objetos que existem num contexto JNDI)  
	precisamos de objetos saibam onde e como obter os objetos. Quando o objeto necessário não é encontrado 
	ele tem que ser construído. Para isso precisamos de objetos que implementem saibam criar os objetos. 
	No MiddleHeaven os objetos <font face="courier">Resolver</font> podem ter ambos os papeis de criador e localizador. 
	Para que o MiddleHeaven possa encontrar os objetos os <font face="courier">Resolver</font>s têm que ser registrados 
	junto ao <font face="courier">WiringService</font>.
	</p>
	<p align="justify">
	Quando um objeto é criado, as suas dependências têm que ser resolvidas, primeiro as do construtor e 
	depois aquelas associadas via um método modificador. Contudo, obtetos da mesma classe A, que dependem de 
	objetos da classe B, não necessáriamente dependem da mesma instancia da classe B. 
	O exemplo clássico é um corretor ortográfico. O corretor precisa de um dicionário, mas nem todos os 
	corretores usam o mesmo dicionário, uns podem usar português, enquanto outros usam o dicionário inglês. 
	Para conseguir distinguir os vários casos precisamos ter controle sobre o vinculo (<font face="courier">Binding</font>) 
	entre o objeto e dependência em que estamos interessados.
	</p>
	<p align="justify">
	O vinculo pode ser definido por outro objeto ou pelo próprio objeto. Ao ser definido pelo próprio objeto 
	não é possível que ele especifique exatamente qual outro objeto ele quer, já que isso seria uma violação
	do <principle>Principio de Inversão de Controle</principle> que estamos tentado respeitar ao máximo. 
	Então , a informação contida no objeto é lida pelo injetor como uma dica de qual objeto deve ser injetado
	naquele ponto. Os vários vínculos (Binding) também devem ser registrados junto ao <font face="courier">WiringService</font>.
	</p>
	
	<h2>ObjectPool</h2>
	<p align="justify">
	O WiringService tem vários tipos de configuração e permite ter acesso ao <font face="courier">ObjectPool</font>. 
	O <font face="courier">ObjectPool</font> (piscina de objetos) representa o local onde os objetos estão, prontos a 
	serem obtidos e injetados em outros objetos. O objeto é obtido pelos métodos <font face="courier">getInstance()</font> de <font face="courier">ObjectPool</font>. 
	De certa forma o <font face="courier">ObjectPool</font> funciona como um objecto <b>Factory</b>/<b>ServiceLocator</b>, 
	inteligente que consegue determinar as dependencias sozinho e carregar os objetos sozinho (apenas com configuração e não com programação).
	</p>
	<h3>Escopos</h3>
	<p align="justify">
	Uma vez criado e devidamente injetado o objeto é devolvido a quem o requisitou. 
	Pode ser interessante guardar esse objeto para uso futuro evitando ter que passar de novo 
	pelo processo de procura e criação seguindo o padrão <b>Shared Object</b>
	( apenas uma instancia do objeto existe, e todo o mundo usa a mesma). Ou pode ser interessante recuperar 
	o objeto de um outro lugar, por exemplo, de um contexto JNDI.  
	Para permitir a implementação destas regras o <font face="courier">ObjectPool</font> é dividido em regiões chamadas 
	escopos (<font face="courier">Scope</font>).Todos os objetos existem realmente dentro de um escopo e não no
	<font face="courier">ObjectPool</font> diretamente.
	
	</p>
	<p align="justify"> 
	Os escopos permitem ter um grau de controle de como os objetos são resolvidos antes que o <font face="courier">Resolver</font> 
	seja invocado. Cada escopo conta com um <font face="courier">ScopePool</font> (piscina de escopo) onde os objetos são mantidos.
	Sendo o <font face="courier">ScopePool</font> um objeto, ele também passa pelo ciclo de injeção, sendo possível injetar um 
	<font face="courier">ScopePool</font> com outros objetos. O MiddleHeaven conta com alguns escopos <i class="estrang">out-of-the-box</i>:
	<ul>
	<li> 
	Default - este é o escopo  principal. Este escopo não guarda os objetos de forma alguma. 
	Cada vez que um objeto é requisitado deste escopo, ele é criado do zero. 
	Este é o comportamento padrão.</li>
	<li>
	Shared - este escopo guarda os objetos de forma que se um objeto é requisitado várias vezes, 
	sempre a mesma instancia é retornada. Em outros frameworks isto é chamado erramente de singleton. 
	Os objetos no escopo shared não têm que implementar o padrão singleton (embora possam). 
	O escopo Shared não torna os objetos "singleton" os torna Shared Object (Objeto Partilhado).
	</li>
	<li>
	Service - este é um escopo especial relacionado à Service Toolbox. Os objetos guardados neste 
	escopo são realmente serviços ( no sentido definido pela Service Toolbox). Os serviços são parecidos 
	com objetos shared, mas têm  um ciclo de vida que permite que uma vez injetados em outro objetos, 
	possam ser modificados em runtime. Isto é util para o redeploy de serviços em que o serviço está 
	indisponível durante um breve período de tempo, enquanto a implementação real é trocada. 
	Este é um escopo muito usado, então o MiddleHeaven dá um suporte especial para ele. 
	O <font face="courier">WiringService</font> está registrado neste escopo, o que permite injetar o <font face="courier">WiringService</font> 
	em qualquer outro objeto. Isto permite utilizá-lo no sem modo semelhante a uma fábrida de objetos.
	</li>
	<li>
    Property - este escopo está associado, normalmente, a um arquivo de internacionalização,
     mas pode ser um simples arquivo de propriedades para configuração ( endereço do banco de dados, por exemplo). 
     É principalmente uma forma de injetar Strings.
    </li>
	</ul>
	
	</p>
	
	<h3>Escopo Local</h3>
	<p align="justify">
	Em algumas situações a injeção tem que ser feita baseada em um contexto local.
	O exemplo clássico é a injeção de um <i class="estrang">controller</i> web com informações presentes 
	no <font face="courier">request</font> ou no <font face="courier">session</font>.  O MiddleHeaven suporta este tipo de injeção em objetos espeficios (como os controlers).
	</p>
	<p align="justify">
	Por enquanto o suporte a escopos locais é nativo ao MiddleHeaven ( i.e. não pode ser configurado ou alterado pelo programador final).
	O único escopo local suportado neste momento é o contexto web utilizado exatamente para a injeção de controlers.
	</p>
	<p align="justify">
	Mais sobre esse assunto é discutido no toolbox web.
	</p>
	
	
	<h3>Pontos de Injeção</h3>
	<p align="justify">
	Para que o processo de injeção funcione o injetor precisa conhecer quais dependências satisfazer e como 
	as satisfazer. Essa informação o MiddleHeaven chama ponto de injeção. Existem, básicamente, três categorias 
	de pontos de injeção.  No construtor, em métodos e em atributos.  A injeção pelo construtor é a mais 
	importante, já que, se o objeto não pode ser criado sem que que esse objetos sejam passados corretamente 
	(passar null não vai adiantar).Após ser criado o objeto conta com métodos e atributos que também podem ser 
	usados como pontos de injeção após a criação do objeto. Normalmente a injeção via construtor é usada para 
	dependências obrigtórias ( o objeto não funciona sem elas) e a injeção por métodos/atributos é usada para 
	dependências opcionais.
	</p>
	<p align="justify">
	O MiddleHeaven não encoraja o uso de inejção por atributos que não sejam publico , embora o suporte, 
	porque isso viola o <principle>Principio de Encapsulamento</principle>. Alguns toolboxes precisam fazer 
	esse tipo de injção devido ao seu dominio de atuação, mas isso é feito sob o controle desse toolbox e 
	não a mando do programador final. Como programador final é aconselhável que use apenas a injeção por 
	construtor e método modificador de forma a seguir boas práticas de programação orientada a objetos.
	</p>
	
	
	<h2>Binding</h2>
	<p align="justify">
	Como colocar objetos no <font face="courier">ObjectPool</font> para que sejam encontrados pelo <font face="courier">WiringService</font> 
	durante a injeção ?  Existem várias formas para fazer isso. Como foi dito, objetos que estejam associados
	a um escopo estão acessivel ao <font face="courier">ObjectPool</font>. Então uma forma é colocar o objeto no escopo.
	Isso é independente de como os objetos chegarama a esse escopo. No exemplo do escopo de JNDI o objeto 
	já existe no escopo ou é colocado por meio externos ao MiddleHeaven ( por exemplo, pelo próprio servidor 
	de aplicaão). Ao usar o escopo de serviços os objetos são disponibilizados porque foram registrados
	o <font face="courier">ServiceRegistry</font> do Service Toolbox. Para o escopo padrão o objeto nem sequer precisa existir. 
	O único requisito é que exista um vinculo definido e a classe do objeto esteja no classpath.
	</p>
	<p align="justify">
	A vinculação ao objeto pode dar-se de três formas:
	<ul>
	<li>Pela Classe - o ponto de injeção é vinculado a uma classe. Essa classe tem que ser compativel com o ponto de estensão.
	O MiddleHeaven irá criar um objeto dessa classe quando a injeção for requisitada. Se esse objeto depende de outros os vinculos são 
	seguindo num ciclo recursivo até que o objeto requisitado possa ser devolvido ou se determine que alguma dependencia está faltando.
	</li>
	<li>Pela instancia - o ponto de injeção é vinculado a uma instancia de uma classe compativel com o ponto de injeção. Essa instancia
	será injetada sempre que aquele vinculo for invocado.
	</li>
	<li>Por um Resolver - o ponto de injeção é vinculado a um objeto Resolver que irá obter o objeto a ser injetado.
	</li>
	</ul>
	</p>
	
	<h2>Ativação</h2>
	<p align="justify">
	O MiddleHeaven utiliza o conceito de ativador. Um ativador é um objeto responsável por obter todas as 
	dependencias necessárias para a criação de um objeto e disponibilizar o objeto já construido. 
	Ele atua como uma <b>Factory</b>. A diferença essencial do activador é a resolução de 
	dependencias. Os ativadores são recolhidos as suas inter-dependencias são analizadas e só depois os 
	ativadores são invocados garantido desta forma que os objetos que precisam ser injetados foram criados
	anteriormente.  Após esse processo inicial, novos ativadores podem ser detetados e invocados adicionando
	objetos ao <font face="courier">ObjectPool</font> em runtime. De forma demelhante os ativadores podem ser desabilitados
	retirando os objetos do <font face="courier">ObjectPool</font>.
	</p>
	<p align="justify">
	Este mecanismo de ativação é essencial a diferentes funcionalidades do MiddleHeaven. 
	Ele é a base para a funcionalidade de instalação/desinstalação de modulos de aplicação e serviços "a quente". 
	O processo de ativação é fundido ao processo de bootstrap permitindo que o Container forneça seus próprios 
	ativadores. Por exemplo, quando o MiddleHeaven rodar dentro do Tomcat um serviço de JNDI pode estar 
	opcionalmente disponivel, enquanto que se rodar num JBoss o serviço de JNDI estará obrigatoriamente 
	disponivel assim como o de envio de email. 
	</p>
	
	<h2>Uso</h2>
	<p align="justify">
	A Wiring Toolbox é mais dificil de explicar do que de exemplificar, mas os exemplos são extensos.
	</p>
	<p align="justify">
	Sendo que ha suporte a qualquer modelo de definição de pontos de injeção existem muitas mais opções 
	reais que as demonstradas ( usar anotações do Java ou de outro framework que não do do MiddleHeaven). 
	Aqui ficam exemplos usando apenas os recursos nativos ao MiddleHeaven.
	</p>
	<p align="justify">
	Para definir um ponto de injeção basta anotá-lo com <font face="courier">@Wire</font>. Para construtores a anotação 
	é dispensável se apenas existir um construtor definido. Para métodos e atributos a anotação é 
	obrigatória para definir o ponto de injeção. A injeção sempre é obrigatória por padrão.
	A anotação <font face="courier">@Wire</font> conta com um parametro <font face="courier">required</font> que alterado para <font face="courier">false</font> 
	torna a injeção opcional (Se o objeto não for encontrado o processo continua assim mesmo). Conta inda como o parametro
	<font face="courier">shareable</font> que quando colocado <font face="courier">false</font> obriga o injetor a criar uma instancia diferente (não partilhada)
	para ser injetada nesse ponto. O MiddleHeaven já cria uma nova instancia diferente por padrão, mas apenas no escolo padrão.
	Se o objeto exige ser injetado com uma instancia diferente e isso não for possivel, devido ao escopo requisitado ou qualquer outro impedimento
	uma exceção será lançada.
	</p>
	<p align="justify"/>
	<p align="justify">A anotação <font face="courier">@Wire</font> pode ser utilzada ainda nos parametros, para alterar a obrigatoriedade ou a partilha</p>
	<p align="justify">
	Para criar o ponto de injeção é só isso que precisa. Agora, para configurar o ponto de injeção. 
	Se nada mais for dito o injeto irá procurar um objeto, no escopo padrão, da classe do parametro/attributo 
	e a primeira encontrada será retornada.  Para escolher o escopo basta anotar com annotação atrelada 
	ao escopo (isso também é configurado como um vinculo). Por exemplo, para dizer que o objeto tem 
	que ser obtido do escopo de serviço é só anotar também com <font face="courier">@Service</font>. Para o escopo de objetos 
	partilhados é <font face="courier">@Shared</font>. A associação entre a anotação e o ScopePool também é determinada por um vinculo e portanto,
	pode ser configurada.
	</p> 
	<p align="justify">
	Acontece que é possivel precisar especificar parametros do serviço - por exemplo,  escolher o dicionário 
	em inglês - para isso basta usar <font face="courier">@Params</font> que recebe um array de strings to tipo 
	"chave=valor" - por exemplo, <font face="courier">@Params("lang=en")</font>.
	Imagine agora que está tentando injetar uma String. Este é um dos objetos mais usados em Java, portanto 
	qual delas usar ? O injetor  irá procurar no escopo de propriedades e poderia usar 
	<font face="courier">@Params("name=chaveDaMensagem")</font> para escolher a chave. Para simplificar, use 
	<font face="courier">@Name(chaveDaMensagem")</font>. 
	O <font face="courier">@Name</font> pode ser ainda usado para o escopo de nomes e diretórios, no escopo web ou para 
	destinguir dois objetos que mapeiam a mesma classe.  Repare que não existem ids como no Spring. 
	O <font face="courier">@Name</font> apenas precisa ser usado em caso de ambiguidade. No caso padrão não haverá problema.
	</p>
	<p align="justify">
	<table align="center" border="0">
<tr align="center">
<td>
<source>





<div align="left" class="java">
<table bgcolor="#ffffff" border="0" cellpadding="3" cellspacing="0">
   <tr>
  
   <td align="left" nowrap="nowrap" valign="top">
    
<font color="#808080">01</font> <font color="#ffffff"/>
<br/>
<font color="#808080">02</font> <font color="#ffffff">  </font>
<font color="#0000c0">
<b>public </b>
</font>
<font color="#c00000">
<b>void </b>
</font>
<font color="#000000">simpleTest</font>
<font color="#000000">(){</font>
<br/>
<font color="#808080">03</font> <font color="#ffffff">    </font>
<font color="#0000c0">
<b>final </b>
</font>
<font color="#000000">MockDisplay md = </font>
<font color="#0000c0">
<b>new </b>
</font>
<font color="#000000">MockDisplay</font>
<font color="#000000">()</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">04</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">05</font> <font color="#ffffff">    </font>
<font color="#008000">// obter diretamente do ServiceRegistry para comodidade de teste</font>
<br/>
<font color="#808080">06</font> <font color="#ffffff">    </font>
<font color="#000000">ServiceRegistry.getService</font>
<font color="#000000">(</font>
<font color="#000000">WiringService.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">.getObjectPool</font>
<font color="#000000">()</font>
<br/>
<font color="#808080">07</font> <font color="#ffffff">    </font>
<font color="#000000">.addConfiguration</font>
<font color="#000000">(</font>
<font color="#0000c0">
<b>new </b>
</font>
<font color="#000000">BindConfiguration</font>
<font color="#000000">(){ </font>
<font color="#008000">// configura vinculos</font>
<br/>
<font color="#808080">08</font> <font color="#ffffff"/>
<br/>
<font color="#808080">09</font> <font color="#ffffff">      </font>
<font color="#646464">@Override</font>
<br/>
<font color="#808080">10</font> <font color="#ffffff">      </font>
<font color="#0000c0">
<b>public </b>
</font>
<font color="#c00000">
<b>void </b>
</font>
<font color="#000000">configure</font>
<font color="#000000">(</font>
<font color="#000000">Binder binder</font>
<font color="#000000">) {</font>
<br/>
<font color="#808080">11</font> <font color="#ffffff">        </font>
<font color="#000000">binder.bind</font>
<font color="#000000">(</font>
<font color="#000000">Displayer.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">.toInstance</font>
<font color="#000000">(</font>
<font color="#000000">md</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">12</font> <font color="#ffffff">        </font>
<font color="#000000">binder.bind</font>
<font color="#000000">(</font>
<font color="#000000">Message.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">.to</font>
<font color="#000000">(</font>
<font color="#000000">HelloMessage.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">13</font> <font color="#ffffff">        </font>
<font color="#000000">binder.bindProperty</font>
<font color="#000000">(</font>
<font color="#000000">String.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">.named</font>
<font color="#000000">(</font>
<font color="#990000">"hello.message"</font>
<font color="#000000">)</font>
<font color="#000000">.toInstance</font>
<font color="#000000">(</font>
<font color="#990000">"Hello"</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">14</font> <font color="#ffffff">        </font>
<font color="#000000">binder.bindProperty</font>
<font color="#000000">(</font>
<font color="#000000">String.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">.named</font>
<font color="#000000">(</font>
<font color="#990000">"hello.name"</font>
<font color="#000000">)</font>
<font color="#000000">.toInstance</font>
<font color="#000000">(</font>
<font color="#990000">"World"</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">15</font> <font color="#ffffff">      </font>
<font color="#000000">}</font>
<br/>
<font color="#808080">16</font> <font color="#ffffff">      </font>
<br/>
<font color="#808080">17</font> <font color="#ffffff">    </font>
<font color="#000000">})</font>
<br/>
<font color="#808080">18</font> <font color="#ffffff">    </font>
<font color="#000000">.getInstance</font>
<font color="#000000">(</font>
<font color="#000000">Greeter.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">) </font>
<font color="#008000">// obtem objeto</font>
<br/>
<font color="#808080">19</font> <font color="#ffffff">    </font>
<font color="#000000">.sayHello</font>
<font color="#000000">()</font>
<font color="#000000">; </font>
<font color="#008000">// invoca método no objeto</font>
<br/>
<font color="#808080">20</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">21</font> <font color="#ffffff">    </font>
<font color="#000000">assertEquals</font>
<font color="#000000">(</font>
<font color="#990000">"Hello, World"</font>
<font color="#000000">, md.getSaing</font>
<font color="#000000">())</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">22</font> <font color="#ffffff">  </font>
<font color="#000000">}</font>
<br/>
<font color="#808080">23</font> <font color="#ffffff">  </font>
    
   </td>
  
   </tr>
</table>
</div>



</source>
</td>
</tr>
<tr>
<td class="legend">
<hr/>
		Código 1: </td>
</tr>
</table>
	Neste exemplo podemos ver como vincular classes a instancias e classes de implementação.
	também podemos ver como vincular instancias a classes usando o argumento named.
	<table align="center" border="0">
<tr align="center">
<td>
<source>





<div align="left" class="java">
<table bgcolor="#ffffff" border="0" cellpadding="3" cellspacing="0">
   <tr>
  
   <td align="left" nowrap="nowrap" valign="top">
    
<font color="#808080">01</font> <font color="#ffffff"/>
<br/>
<font color="#808080">02</font> <font color="#ffffff">  </font>
<br/>
<font color="#808080">03</font> <font color="#ffffff">  </font>
<font color="#0000c0">
<b>public </b>
</font>
<font color="#c00000">
<b>void </b>
</font>
<font color="#000000">testWiringServiceWithParams</font>
<font color="#000000">(){</font>
<br/>
<font color="#808080">04</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">05</font> <font color="#ffffff"/>
<br/>
<font color="#808080">06</font> <font color="#ffffff">    </font>
<font color="#000000">ObjectPool pool = </font>
<font color="#0000c0">
<b>this</b>
</font>
<font color="#000000">.getWriringContext</font>
<font color="#000000">()</font>
<br/>
<font color="#808080">07</font> <font color="#ffffff">    </font>
<font color="#000000">.addConfiguration</font>
<font color="#000000">(</font>
<font color="#0000c0">
<b>new </b>
</font>
<font color="#000000">BindConfiguration</font>
<font color="#000000">(){</font>
<br/>
<font color="#808080">08</font> <font color="#ffffff"/>
<br/>
<font color="#808080">09</font> <font color="#ffffff">      </font>
<font color="#646464">@Override</font>
<br/>
<font color="#808080">10</font> <font color="#ffffff">      </font>
<font color="#0000c0">
<b>public </b>
</font>
<font color="#c00000">
<b>void </b>
</font>
<font color="#000000">configure</font>
<font color="#000000">(</font>
<font color="#000000">Binder binder</font>
<font color="#000000">) {</font>
<br/>
<font color="#808080">11</font> <font color="#ffffff">        </font>
<font color="#000000">binder.bind</font>
<font color="#000000">(</font>
<font color="#000000">DictionaryService.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">.in</font>
<font color="#000000">(</font>
<font color="#000000">Service.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">12</font> <font color="#ffffff">        </font>
<font color="#000000">binder.bindScope</font>
<font color="#000000">(</font>
<font color="#000000">Service.class, ServiceScope.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">13</font> <font color="#ffffff">      </font>
<font color="#000000">}</font>
<br/>
<font color="#808080">14</font> <font color="#ffffff">      </font>
<br/>
<font color="#808080">15</font> <font color="#ffffff">    </font>
<font color="#000000">})</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">16</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">17</font> <font color="#ffffff"/>
<br/>
<font color="#808080">18</font> <font color="#ffffff">    </font>
<font color="#000000">ServiceContext serviceContext = pool.getInstance</font>
<font color="#000000">(</font>
<font color="#000000">ServiceContext.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">19</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">20</font> <font color="#ffffff">    </font>
<font color="#000000">ParamsMap paramsEn = </font>
<font color="#0000c0">
<b>new </b>
</font>
<font color="#000000">ParamsMap</font>
<font color="#000000">()</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">21</font> <font color="#ffffff">    </font>
<font color="#000000">paramsEn.put</font>
<font color="#000000">(</font>
<font color="#990000">"lang"</font>
<font color="#000000">, </font>
<font color="#990000">"en"</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">22</font> <font color="#ffffff">    </font>
<font color="#000000">serviceContext.register</font>
<font color="#000000">(</font>
<font color="#000000">DictionaryService.class, </font>
<font color="#0000c0">
<b>new </b>
</font>
<font color="#000000">HashDictionaryService</font>
<font color="#000000">(</font>
<font color="#990000">"en"</font>
<font color="#000000">)</font>
<font color="#000000">,paramsEn</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">23</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">24</font> <font color="#ffffff">    </font>
<font color="#000000">ParamsMap paramsPT = </font>
<font color="#0000c0">
<b>new </b>
</font>
<font color="#000000">ParamsMap</font>
<font color="#000000">()</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">25</font> <font color="#ffffff">    </font>
<font color="#000000">paramsPT.put</font>
<font color="#000000">(</font>
<font color="#990000">"lang"</font>
<font color="#000000">, </font>
<font color="#990000">"pt"</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">26</font> <font color="#ffffff">    </font>
<font color="#000000">serviceContext.register</font>
<font color="#000000">(</font>
<font color="#000000">DictionaryService.class, </font>
<font color="#0000c0">
<b>new </b>
</font>
<font color="#000000">HashDictionaryService</font>
<font color="#000000">(</font>
<font color="#990000">"pt"</font>
<font color="#000000">)</font>
<font color="#000000">,paramsPT</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">27</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">28</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">29</font> <font color="#ffffff">    </font>
<font color="#000000">DictionaryService enDic = pool.getInstance</font>
<font color="#000000">(</font>
<font color="#000000">DictionaryService.class, paramsEn</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">30</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">31</font> <font color="#ffffff">    </font>
<font color="#000000">assertEquals</font>
<font color="#000000">(</font>
<font color="#990000">"en"</font>
<font color="#000000">, enDic.getLang</font>
<font color="#000000">())</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">32</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">33</font> <font color="#ffffff">    </font>
<font color="#000000">DictionaryService ptDic = pool.getInstance</font>
<font color="#000000">(</font>
<font color="#000000">DictionaryService.class, paramsPT</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">34</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">35</font> <font color="#ffffff">    </font>
<font color="#000000">assertEquals</font>
<font color="#000000">(</font>
<font color="#990000">"pt"</font>
<font color="#000000">, ptDic.getLang</font>
<font color="#000000">())</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">36</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">37</font> <font color="#ffffff">    </font>
<font color="#008000">// with no params the service scope will choose one of the existing implementations</font>
<br/>
<font color="#808080">38</font> <font color="#ffffff">    </font>
<font color="#000000">DictionaryService eDic = pool.getInstance</font>
<font color="#000000">(</font>
<font color="#000000">DictionaryService.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">39</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">40</font> <font color="#ffffff">    </font>
<font color="#000000">assertNotNull</font>
<font color="#000000">(</font>
<font color="#000000">eDic</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">41</font> <font color="#ffffff">    </font>
<br/>
<font color="#808080">42</font> <font color="#ffffff">  </font>
<font color="#000000">}</font>
<br/>
<font color="#808080">43</font> <font color="#ffffff">  </font>
    
   </td>
  
   </tr>
</table>
</div>



</source>
</td>
</tr>
<tr>
<td class="legend">
<hr/>
		Código 2: </td>
</tr>
</table>
	Neste exemplo podemos ver como vincular escopos e como usar parametros para diferenciar entre implementações.
	</p>
	
	
	<h2>Por detrás dos panos</h2>
	<p align="justify">
	Este toolbox é completamente implementado com recursos da plataforma Java sem utilizar nenhuma API externa. 
	Isto é proposital. Primeiro por causa da diretiva principal de isolar tecnologias. Segundo porque as API que existem
	não são suficientemente genéricas. Afinal anotações amarram o seu código aos frameworks tanto quanto implementar
	interfaces ou extender classes. É uma questão de quanto amarram, e não se amarram ou não. Isto é um grande problema.
	Imagine que você já tem um conjunto de classes que quer injetar e ver injetadas no seu novo sistema construido como 
	MiddleHeaven. O MiddleHeaven não pode lhe exigir que coloque anotações em todas elas. Isso implica em alterar o codigo 
	original. Por isto o MiddleHeaven tem que permitir extender-se até às suas necessidades. 
	</p>
	
	</body>
<h2>Licença</h2>
<table align="center" width="70%">
<tr>
<td align="center" valign="center">
<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" rel="license">
<img alt="Creative Commons License" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" style="border-width:0"/>
</a>
</td>
<td align="left" valign="top">  Sérgio Taborda<br/>
				      Este trabalho é licenciado sob a <br/>
<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.pt" rel="license" target="_new">
						Licença Creative Commons Atribuição-Uso Não-Comercial-Não a obras derivadas 3.0 Genérica
						</a>.
						
				      </td>
</tr>
</table>
</body>
