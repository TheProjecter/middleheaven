<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<body>
<body>
	<h2>Service Toolbox</h2>
	<p align="justify">
	A Service Toolbox é a API de serviços do MiddleHeaven e uma das peças 
	essenciais na sua arquitetura.
	</p>
	<p align="justify">
	Para o MiddleHeven um serviço é um contrato representado por uma interface Java.
	O contrato tem várias implementações possiveis ( dai o uso de uma interface Java 
	para o representar). Sendo que um contrato têm várias implementações é 
	necessário um registro de qual implementação está sendo utilizada correntemente.
	</p>
	
	<h2>ServiceRegistry</h2>
	<p align="justify">
	O objeto <font face="courier">ServiceRegistry</font> é um registro de serviços seguindo o 
	padrão <b>Registry</b>. Para registrar um serviço precisamos da 
	interface do contrato, uma implementação desse contrato, e opcionalmente 
	precisamos de parametros para destinguir uma implementação de outra, 
	para o mesmo serviço.
	</p>
	<p align="justify">
	O exemplo clássico de serviços com implementações diferentes 
	usados simultaneamente é o de dicionários. Podemos ter um serviço 
	de dicionário que funciona para portugues e outro para espanhol e 
	podemos querer usar os dois simultaneamente.
	</p>
	
	<h2>Ciclo de Vida de um Serviço</h2>
	<p align="justify">
	Um serviço pode estar registrado, não-registrado ou em alteração. 
	Quando um serviço está disponivel no <font face="courier">ServiceRegistry</font> ele está 
	no estado registrado (<font face="courier">REGISTRED</font>). Quando o serviço é removido 
	do registro está não-registrado (<font face="courier">UNREGISTRED</font>). Pode acontecer 
	que uma nova implementação do serviço está substituindo a antiga. 
	Durante este processo o serviço não pode ser usado, mas ele está no registro. 
	Durante este processo o serviço está em estado de alteração (<font face="courier">UPDATE</font>). 
	O <font face="courier">ServiceRegister</font> permite que sejam cadastrados listeners para 
	responder ao estado do serviço.
	</p>
	<p align="justify">
	Quando um serviço é requisitado ao <font face="courier">ServiceRegistry</font> não é retornada 
	a implementação do serviço e sim um proxy para essa implementação. 
	Isto porque, quando o serviço é alterado por outro, o objeto que necessita do 
	serviço ainda têm uma referencia válida ao serviço, apenas a implementação muda. 
	O proxy  bloqueia o acesso ao serviço enquanto a alteração é feita. 
	Quando o serviço é removido permanentemente o proxy lança uma exceção 
	<font face="courier">ServiceNotFoundException</font>. O proxy é capaz de avaliar o estado de 
	acesso ao serviço porque ele recebe os eventos do ciclo de vida do serviço a 
	que está acoplado.
	</p>
	
	<h2>Ativação</h2>
 	<p align="justify">
	Além de ser possivel registrar os serviços no <font face="courier">ServiceRegistry</font> 
	diretamente é ainda possivel iniciar um serviço por ativação.  
	O <font face="courier">WiringService</font> permite que qualquer objeto possa ser ativado, 
	e isso, claro, inclui os serviços. A ideia é que serviços opcionais possam 
	ser adicionados/alterados a quente durante o funcionamento da aplicação. 
	Para isso basta seguir o processo normal de ativação.
	</p>
	
	
	<h2>Publicação e Subscrição</h2>
	<p align="justify">
	Serviços são acessiveis pelo <font face="courier">ServiceRegistry</font> e/ou pelo 
	<font face="courier">WiringService</font> mas apenas dentro da mesma JVM, no mesmo contexto 
	de classloading. Se quiser que o serviço possa ser acessado de outros 
	contextos ou quiser acessar serviços presentes em outros contexto é 
	necessário algo mais.
	</p>
	<p align="justify">
	O serviço de publicação de serviços tornar os serviços acessiveis por 
	outros mecanismos. Nomeadamente por mecanismos remotos como web services.
	</p>
	<p align="justify">
	O serviço de subscrição de serviços torna possivel trazer serviços 
	externos para dentro do <font face="courier">ServiceRegistry</font>. 
	Por exemplo, consumir um web service disponibilizado na web e registrá-lo
	com uma certa interface no <font face="courier">ServiceRegistry</font>. 
	É uma implementação remota do serviço.
	</p>
	<p align="justify">
	Outras opções são ainda interagir com um EBS subscrevendo-se ao ponto de entrada de um processo ou
	disponibilizar o serviço via Jini ou RMI.
	</p>	
	<p align="justify">
	A toolbox de Serviços visa trazer a orientação a serviços para dentro das suas aplicações de uma forma 
	orientada a objetos utilizando interfaces java. 
	</p>

	<p align="justify">
	Os serviços de publicação e subscrição ainda não estão implementados mas são
	uma das ideias para um futuro breve já que são necessários no mundo de hoje onde as aplicação são
	connectadas. Especialmente se tomarmos em consideração o mundo JME que precisa interagir com um servidor. 
	</p>
	
	
	<h2>Uso</h2>
	<p align="justify">
	Normalmente  quem usa o <font face="courier">ServiceRegistry</font> é o próprio MiddleHeaven, 
	para o programador final o uso do <font face="courier">WiringService</font> é recomendado. 
	Contudo é bom entender que o <font face="courier">ServiceRegistry</font>é o coração do MiddleHeaven
	já que todos os toolbox têm alguma forma de interagir com isso, 
	seja disponibilizando serviços, seja dependendo de outros serviços.
	</p>
	<p align="justify">
	O <font face="courier">WiringService</font> é um motor de injeção automática de dependencia 
	enquanto que o uso do <font face="courier">ServiceRegistry</font> é mais próximo ao de um 
	<b>ServiceLocator</b>. O <font face="courier">WiringService</font> disponibiliza 
	o escopo de serviço exactamente para esconder o uso do <font face="courier">ServiceRegistry</font> 
	para o programador final. Em outras palavras, o <font face="courier">ServiceRegistry</font> tem 
	que ser conhecido por quem desenvolve o MiddleHeavem em si, mas não para quem usa o 
	MiddleHeavem para criar suas próprias aplicações. Para esses, o <font face="courier">WiringService</font> 
	é o cara.
	</p>
	
	<p align="justify">
	Dito isto, aqui fica uma demonstração de como seria utilizar o <font face="courier">ServiceRegistry</font>:
	<table align="center" border="0">
<tr align="center">
<td>
<source>





<div align="left" class="java">
<table bgcolor="#ffffff" border="0" cellpadding="3" cellspacing="0">
   <tr>
  
   <td align="left" nowrap="nowrap" valign="top">
    
<font color="#808080">1</font> <font color="#ffffff"/>
<br/>
<font color="#808080">2</font> <font color="#ffffff">  </font>
<font color="#008000">// em algum lugar da aplicação (normalmente o Container)</font>
<br/>
<font color="#808080">3</font> <font color="#ffffff">   </font>
<font color="#000000">ServiceRegistry.register</font>
<font color="#000000">(</font>
<font color="#000000">NameDirectoryService.class, </font>
<font color="#0000c0">
<b>new </b>
</font>
<font color="#000000">JNDINameDirectoryService</font>
<font color="#000000">())</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">4</font> <font color="#ffffff">  </font>
<br/>
<font color="#808080">5</font> <font color="#ffffff">  </font>
<font color="#008000">// em algum outro lugar da aplicação</font>
<br/>
<font color="#808080">6</font> <font color="#ffffff">  </font>
<font color="#000000">NameDirectoryService service = ServiceRegistry.getService</font>
<font color="#000000">(</font>
<font color="#000000">NameDirectoryService.</font>
<font color="#0000c0">
<b>class</b>
</font>
<font color="#000000">)</font>
<font color="#000000">;</font>
<br/>
<font color="#808080">7</font> <font color="#ffffff">  </font>
<font color="#008000">// use o serviço</font>
<br/>
<font color="#808080">8</font> <font color="#ffffff">  </font>
    
   </td>
  
   </tr>
</table>
</div>



</source>
</td>
</tr>
<tr>
<td class="legend">
<hr/>
		Código 1: </td>
</tr>
</table>
	</p>
	
	
	<h2>Por detrás dos Panos</h2>
	<p align="justify">
	Não ha outras API sendo usadas por detrás dos panos neste toolbox. 
	Apenas o uso extensivo dos padrões <b>Registry</b>, <b>Service</b>, <b>Proxy</b> e <b>Observer</b>.  
	Tudo implementado puramente em Java pelo MiddleHaven. A razão é simples: é uma API muito importante para dependender de outras API externas.
	</p>

	<p align="justify">
	Contudo, existe um "truque" no que diz respeito à forte interação entre o 
	<font face="courier">ServiceRegistry</font> e o <font face="courier">WiringService</font>. 
	O <font face="courier">WiringService</font> é um serviço, pelo que tem que estar registrado 
	no <font face="courier">ServiceRegistry</font>, mas ele injeta serviços nos objetos que 
	gerencia, pelo que tem que ser possivel ler do <font face="courier">ServiceRegistry</font>. 
	Em particular, lêr-se a ele próprio quando é requisitado para injeção em 
	algum objeto. O que faz isto funcionar é o mecanismo de bootstrap.
	Durante o bootstrap o container pode registrar o serviço que quiser. Se o MiddleHeaven está rodando dentro
	de um servidor de aplicação JEE, por exemplo, váris serviços já estão disponivies (transação, envio de email, jndi)
	Ao registrar os serviços ele ficam automáticamente disponiveis para injeção.
	</p>
	
	<p align="justify">
	No inicio do desenvolvimento foi cotada a opção de usar OSGi para integrar os 
	serviços. Contudo isso nos deixaria com um modelo muito dependente das 
	limitações do OSGi. Desta forma é possivel criar um mecanismo de subscrição 
	que entenda e utilize serviços OSGi e até encapsular o MiddleHeaven, 
	ou seus serviços, como serviços OSGi. Mas isso é coisa para um futuro 
	bem mais longinquo.
	</p>

	<p align="justify">
	O processo de ativação utilizado pelo MiddleHeaven é bem semelhante ao usado 
	pelo OSGi, mas a resolução de dependencias é feita pelo motor de injeção o 
	que permite que os ativadores apenas tenham que declarar de quais serviços 
	são dependentes e quais eles publicam ao nivel do código sem precisar de artefactos como arquivos de manifesto. 
	A grande diferença é que o MiddleHeaven exige que um serviço seja um  contrato + uma implementação, 
	coisa que o OSGi não exige.Isso não é uma limitação porque está mais de acordo 
	com o conceito do padrão Service e permite mais flexibilidade, já que é possivel 
	utilizar proxies.
	</p>

	<p align="justify">
	O Java 7 irá trazer um mecanismo especial para modulurização de código. 
	Este modelo é diferente do seguido pelo OSGi e os dois não são mutuamente 
	excludentes. Esperando para ver no que dá e como o MiddleHeaven 
	se pode beneficiar disso.Por agora um ativador pode estar obtido de arquivos jar
	devidamente configurados.
	</p>
	
	
	</body>
<h2>Licença</h2>
<table align="center" width="70%">
<tr>
<td align="center" valign="center">
<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" rel="license">
<img alt="Creative Commons License" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" style="border-width:0"/>
</a>
</td>
<td align="left" valign="top">  Sérgio Taborda<br/>
				      Este trabalho é licenciado sob a <br/>
<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.pt" rel="license" target="_new">
						Licença Creative Commons Atribuição-Uso Não-Comercial-Não a obras derivadas 3.0 Genérica
						</a>.
						
				      </td>
</tr>
</table>
</body>
