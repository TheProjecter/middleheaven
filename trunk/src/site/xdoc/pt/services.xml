<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<author>Sérgio Taborda</author>
		<title> Service Toolbox </title>
	</properties>
	<body>
	<section name="Service Toolbox">
	<p>
	A Service Toolbox é a API de serviços do MiddleHeaven e uma das peças 
	essenciais na sua arquitetura.
	</p>
	<p>
	Para o MiddleHeven um serviço é um contrato representado por uma interface Java.
	O contrato tem várias implementações possiveis ( dai o uso de uma interface Java 
	para o representar). Sendo que um contrato têm várias implementações é 
	necessário um registro de qual implementação está sendo utilizada correntemente.
	</p>
	</section>
	<section name="ServiceRegistry">
	<p>
	O objeto <code>ServiceRegistry</code> é um registro de serviços seguindo o 
	padrão <pattern>Registry</pattern>. Para registrar um serviço precisamos da 
	interface do contrato, uma implementação desse contrato, e opcionalmente 
	precisamos de parametros para destinguir uma implementação de outra, 
	para o mesmo serviço.
	</p>
	<p>
	O exemplo clássico de serviços com implementações diferentes 
	usados simultaneamente é o de dicionários. Podemos ter um serviço 
	de dicionário que funciona para portugues e outro para espanhol e 
	podemos querer usar os dois simultaneamente.
	</p>
	</section>
	<section name="Ciclo de Vida de um Serviço" >
	<p>
	Um serviço pode estar registrado, não-registrado ou em alteração. 
	Quando um serviço está disponivel no <code>ServiceRegistry</code> ele está 
	no estado registrado (<code>REGISTRED</code>). Quando o serviço é removido 
	do registro está não-registrado (<code>UNREGISTRED</code>). Pode acontecer 
	que uma nova implementação do serviço está substituindo a antiga. 
	Durante este processo o serviço não pode ser usado, mas ele está no registro. 
	Durante este processo o serviço está em estado de alteração (<code>UPDATE</code>). 
	O <code>ServiceRegister</code> permite que sejam cadastrados listeners para 
	responder ao estado do serviço.
	</p>
	<p>
	Quando um serviço é requisitado ao <code>ServiceRegistry</code> não é retornada 
	a implementação do serviço e sim um proxy para essa implementação. 
	Isto porque, quando o serviço é alterado por outro, o objeto que necessita do 
	serviço ainda têm uma referencia válida ao serviço, apenas a implementação muda. 
	O proxy  bloqueia o acesso ao serviço enquanto a alteração é feita. 
	Quando o serviço é removido permanentemente o proxy lança uma exceção 
	<code>ServiceNotFoundException</code>. O proxy é capaz de avaliar o estado de 
	acesso ao serviço porque ele recebe os eventos do ciclo de vida do serviço a 
	que está acoplado.
	</p>
	</section>
	<section name="Ativação" >
 	<p>
	Além de ser possivel registrar os serviços no <code>ServiceRegistry</code> 
	diretamente é ainda possivel iniciar um serviço por ativação.  
	O <code>WiringService</code> permite que qualquer objeto possa ser ativado, 
	e isso, claro, inclui os serviços. A ideia é que serviços opcionais possam 
	ser adicionados/alterados a quente durante o funcionamento da aplicação. 
	Para isso basta seguir o processo normal de ativação.
	</p>
	</section>
	
	<section name="Publicação e Subscrição" >
	<p>
	Serviços são acessiveis pelo <code>ServiceRegistry</code> e/ou pelo 
	<code>WiringService</code> mas apenas dentro da mesma JVM, no mesmo contexto 
	de classloading. Se quiser que o serviço possa ser acessado de outros 
	contextos ou quiser acessar serviços presentes em outros contexto é 
	necessário algo mais.
	</p>
	<p>
	O serviço de publicação de serviços tornar os serviços acessiveis por 
	outros mecanismos. Nomeadamente por mecanismos remotos como web services.
	</p>
	<p>
	O serviço de subscrição de serviços torna possivel trazer serviços 
	externos para dentro do <code>ServiceRegistry</code>. 
	Por exemplo, consumir um web service disponibilizado na web e registrá-lo
	com uma certa interface no <code>ServiceRegistry</code>. 
	É uma implementação remota do serviço.
	</p>
	<p>
	Outras opções são ainda interagir com um EBS subscrevendo-se ao ponto de entrada de um processo ou
	disponibilizar o serviço via Jini ou RMI.
	</p>	
	<p>
	A toolbox de Serviços visa trazer a orientação a serviços para dentro das suas aplicações de uma forma 
	orientada a objetos utilizando interfaces java. 
	</p>

	<p>
	Os serviços de publicação e subscrição ainda não estão implementados mas são
	uma das ideias para um futuro breve já que são necessários no mundo de hoje onde as aplicação são
	connectadas. Especialmente se tomarmos em consideração o mundo JME que precisa interagir com um servidor. 
	</p>
	</section>
	
	<section name="Uso">
	<p>
	Normalmente  quem usa o <code>ServiceRegistry</code> é o próprio MiddleHeaven, 
	para o programador final o uso do <code>WiringService</code> é recomendado. 
	Contudo é bom entender que o <code>ServiceRegistry</code>é o coração do MiddleHeaven
	já que todos os toolbox têm alguma forma de interagir com isso, 
	seja disponibilizando serviços, seja dependendo de outros serviços.
	</p>
	<p>
	O <code>WiringService</code> é um motor de injeção automática de dependencia 
	enquanto que o uso do <code>ServiceRegistry</code> é mais próximo ao de um 
	<pattern>ServiceLocator</pattern>. O <code>WiringService</code> disponibiliza 
	o escopo de serviço exactamente para esconder o uso do <code>ServiceRegistry</code> 
	para o programador final. Em outras palavras, o <code>ServiceRegistry</code> tem 
	que ser conhecido por quem desenvolve o MiddleHeavem em si, mas não para quem usa o 
	MiddleHeavem para criar suas próprias aplicações. Para esses, o <code>WiringService</code> 
	é o cara.
	</p>
	
	<p>
	Dito isto, aqui fica uma demonstração de como seria utilizar o <code>ServiceRegistry</code>:
	<source>
	// em algum lugar da aplicação (normalmente o Container)
	 ServiceRegistry.register(NameDirectoryService.class, new JNDINameDirectoryService());
	
	// em algum outro lugar da aplicação
	NameDirectoryService service = ServiceRegistry.getService(NameDirectoryService.class);
	// use o serviço
	</source>
	</p>
	</section>
	
	<section name="Por detrás dos Panos" >
	<p>
	Não ha outras API sendo usadas por detrás dos panos neste toolbox. 
	Apenas o uso extensivo dos padrões <pattern>Registry</pattern>, <pattern>Service</pattern>, <pattern>Proxy</pattern> e <pattern>Observer</pattern>.  
	Tudo implementado puramente em Java pelo MiddleHaven. A razão é simples: é uma API muito importante para dependender de outras API externas.
	</p>

	<p>
	Contudo, existe um "truque" no que diz respeito à forte interação entre o 
	<code>ServiceRegistry</code> e o <code>WiringService</code>. 
	O <code>WiringService</code> é um serviço, pelo que tem que estar registrado 
	no <code>ServiceRegistry</code>, mas ele injeta serviços nos objetos que 
	gerencia, pelo que tem que ser possivel ler do <code>ServiceRegistry</code>. 
	Em particular, lêr-se a ele próprio quando é requisitado para injeção em 
	algum objeto. O que faz isto funcionar é o mecanismo de bootstrap.
	Durante o bootstrap o container pode registrar o serviço que quiser. Se o MiddleHeaven está rodando dentro
	de um servidor de aplicação JEE, por exemplo, váris serviços já estão disponivies (transação, envio de email, jndi)
	Ao registrar os serviços ele ficam automáticamente disponiveis para injeção.
	</p>
	
	<p>
	No inicio do desenvolvimento foi cotada a opção de usar OSGi para integrar os 
	serviços. Contudo isso nos deixaria com um modelo muito dependente das 
	limitações do OSGi. Desta forma é possivel criar um mecanismo de subscrição 
	que entenda e utilize serviços OSGi e até encapsular o MiddleHeaven, 
	ou seus serviços, como serviços OSGi. Mas isso é coisa para um futuro 
	bem mais longinquo.
	</p>

	<p>
	O processo de ativação utilizado pelo MiddleHeaven é bem semelhante ao usado 
	pelo OSGi, mas a resolução de dependencias é feita pelo motor de injeção o 
	que permite que os ativadores apenas tenham que declarar de quais serviços 
	são dependentes e quais eles publicam ao nivel do código sem precisar de artefactos como arquivos de manifesto. 
	A grande diferença é que o MiddleHeaven exige que um serviço seja um  contrato + uma implementação, 
	coisa que o OSGi não exige.Isso não é uma limitação porque está mais de acordo 
	com o conceito do padrão Service e permite mais flexibilidade, já que é possivel 
	utilizar proxies.
	</p>

	<p>
	O Java 7 irá trazer um mecanismo especial para modulurização de código. 
	Este modelo é diferente do seguido pelo OSGi e os dois não são mutuamente 
	excludentes. Esperando para ver no que dá e como o MiddleHeaven 
	se pode beneficiar disso.Por agora um ativador pode estar obtido de arquivos jar
	devidamente configurados.
	</p>
	
	</section>
	</body>
</document>
